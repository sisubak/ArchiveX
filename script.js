const clientsData = [
    {
        title: "ae86 client vae5",
        type: "teeworlds cheat",
        badge: "teeworlds • cheat",
        description: "модифицированная версия sash client от русского разработчика с улучшенным функционалом",
        image: "https://i.postimg.cc/L5XYVw5j/Ae86-Client-b-Rsph-Qx-Yd-C.png",
        download: "https://drive.google.com/file/d/1kc2a6ccX0Io4x4Y4pkcFbGn4ihAsufLU/view?usp=sharing",
        arts: [
            "https://i.postimg.cc/TYjz6nvn/image.png",
            "https://i.postimg.cc/kMKZQWGt/image.png",
            "https://i.postimg.cc/MTRsY8WL/image.png",
            "https://i.postimg.cc/Qdt0y78g/image.png"
        ]
    },
    {
        title: "ae86 client vae6 beta",
        type: "teeworlds cheat",
        badge: "ddnet • cheat",
        description: "новая бета версия клиента ae86 client",
        image: "https://i.postimg.cc/TPX4yVND/image.png",
        download: "https://drive.google.com/file/d/1d8EPjCQTdrJj4llGI2QUwnim8d97arUk/view?usp=sharing",
        arts: [
            "https://i.postimg.cc/TYjz6nvn/image.png",
            "https://i.postimg.cc/kMKZQWGt/image.png",
            "https://i.postimg.cc/MTRsY8WL/image.png",
            "https://i.postimg.cc/Qdt0y78g/image.png"
        ]
    },
    {
        title: "dd.cff client",
        type: "ddnet cheat",
        badge: "ddnet • cheat",
        description: "мощный клиент для ddnet с отличным чит функционалом",
        image: "https://i.postimg.cc/nrPsS29g/dd-cff.png",
        download: "https://drive.google.com/file/d/1l7-glaPC6VH8ffpkFG4w8r7h8wFOSymp/view?usp=sharing",
        arts: ["https://i.postimg.cc/9FGhQvZy/image.png"]
    },
    {
        title: "goreworlds client",
        type: "teeworlds",
        badge: "teeworlds",
        description: "клиент имеющий 16+ отметку так как имеет кровь и другие вещи",
        image: "https://i.postimg.cc/158VnkLQ/Goreworlds-g27du-XIFXy.png",
        download: "https://drive.google.com/file/d/1yF6pZtd9w4x7-uNlRMlN2sDPLAP7aJgc/view?usp=sharing"
    },
    {
        title: "nn client crack",
        type: "ddnet",
        badge: "ddnet • cheat",
        description: "похож на tclientv3 plus, но улучшенный функционал",
        image: "https://i.postimg.cc/B6gS75VW/image.png",
        download: "https://drive.google.com/file/d/1ckCVIP2HAZPDuPsqcsEWJdcTkOnUMuHk/view?usp=sharing"
    },
    {
        title: "sash upgradev32",
        type: "teeworlds cheat",
        badge: "teeworlds • cheat",
        description: "обновленная версия популярного клиента sash",
        image: "https://i.postimg.cc/9QGYfLgC/DDNet-f-FKHEV6m-BU.png",
        download: "https://drive.google.com/file/d/1dj57EspAJG3SepJtIx33RY4-R7jiSlhm/view?usp=sharing",
        arts: ["https://i.postimg.cc/nrp1YjSJ/image.png"]
    },
    {
        title: "saiko",
        type: "teeworlds cheat",
        badge: "ddnet • cheat",
        description: "tclient, но с avoid freeze функционалом саппорт",
        image: "https://i.postimg.cc/CxpZ956N/image.png",
        download: "https://drive.google.com/file/d/1OBtyT__yH9MmuFxgcddySd5B2I3EfTL3/view?usp=sharing"
    },
    {
        title: "sakura client",
        type: "ddnet",
        badge: "ddnet",
        description: "элегантный клиент с уникальным дизайном",
        image: "https://i.postimg.cc/YCT1ndNg/DDNet-Nvq-Le-PTl3l.png",
        download: "https://drive.google.com/file/d/1dAN7qLy7EBhL5fpjM2Q3dgUNOO-o7bYl/view?usp=sharing"
    },
    {
        title: "sash by akrd1337",
        type: "teeworlds cheat",
        badge: "teeworlds • cheat",
        description: "модифицированная версия sash клиента",
        image: "https://i.postimg.cc/RF0yrWQr/Sash-crack-9-Bk-Px-GRpz-A.png",
        download: "https://drive.google.com/file/d/1TZLt4QWUcG5BXxzw4_BLi4f6yJMbs3hQ/view?usp=sharing",
        arts: ["https://i.postimg.cc/nrp1YjSJ/image.png"]
    },
    {
        title: "jimjam client",
        type: "teeworlds",
        badge: "teeworlds",
        description: "прикольный клиент, в нем есть много разных полезных функций",
        image: "https://i.postimg.cc/HWZ7LYvz/jimjam.png",
        download: "https://drive.google.com/file/d/1_o3R3FQs3Jv3ARDJKz2EslMxJLbZPJZG/view?usp=sharing"
    },
    {
        title: "k-client",
        type: "teeworlds cheat",
        badge: "teeworlds • cheat",
        description: "клиент похожий на krx, но на teeworlds",
        image: "https://i.postimg.cc/HxtXzb21/K-Client-ENFC6b2kks.png",
        download: "https://drive.google.com/file/d/1CknKAMSTwWoU3OlPwMacin0mqfAaBiRY/view?usp=sharing"
    },
    {
        title: "krx client crack 1.32",
        type: "ddnet cheat",
        badge: "ddnet • cheat • premium",
        description: "крякнутая версия krx клиента 1.32 с рабочим когом",
        image: "https://i.postimg.cc/RhVfDqs6/KRX-Client-1-32.png",
        buy: "https://t.me/Doibronetri",
        arts: [
            "https://i.postimg.cc/kgb7KB0Q/image.png",
            "https://i.postimg.cc/VNFQWMD5/image.png"
        ]
    },
    {
        title: "krx client 1.32 crack",
        type: "ddnet",
        badge: "ddnet • cheat • crack",
        description: "кряк крякнутой версия krx клиента 1.32, но не рабочим когом пароль от архива: 1",
        image: "https://i.postimg.cc/25c5w7b1/image.png",
        download: "https://drive.google.com/file/d/1DlHPGvhOozqGMM2PliZKBgY6QtD4jjvU/view?usp=sharing",
        arts: [
            "https://i.postimg.cc/kgb7KB0Q/image.png",
            "https://i.postimg.cc/VNFQWMD5/image.png"
        ]
    },
    {
        title: "mario client",
        type: "teeworlds",
        badge: "teeworlds",
        description: "тематический клиент с одной функции которая добавляет визуального mario на сервер",
        image: "https://i.postimg.cc/qMqych6W/mario.png",
        download: "https://drive.google.com/file/d/1wrDlSev7R_3c33wP87tXaFD2dLireEL-/view?usp=sharing"
    },
    {
        title: "pulse client",
        type: "ddnet",
        badge: "ddnet",
        description: "новый клиент сильно вдохновленный cactus client'ом",
        image: "https://i.postimg.cc/Pf218zJm/pulse-client.png",
        download: "https://drive.google.com/file/d/100huDXqIS2xmbM1vxAi3YCM_UjxInq8l/view?usp=sharing"
    },
    {
        title: "s-client",
        type: "teeworlds",
        badge: "teeworlds",
        description: "клиент похожий на tclient, но на teewoorlds",
        image: "https://i.postimg.cc/d3HdPvpW/S-Client-Ys-E8k9f-B1w.png",
        download: "https://drive.google.com/file/d/1bUL49r3GTPZInQUZx-fr_WtNmaEanUU4/view?usp=sharing"
    },
    {
        title: "sqclient",
        type: "ddnet cheat",
        badge: "ddnet • cheat",
        description: "новый чит клиент, а точнее его крякнутая версия модификация tclient, но с читами",
        image: "https://i.postimg.cc/vZ6njJzz/SQClient.png",
        download: "https://drive.google.com/file/d/1nAvrsid6ZItkiCzBzBcDToCNjskj5pnC/view?usp=sharing"
    },
    {
        title: "sta client",
        type: "teeworlds cheat",
        badge: "teeworlds • cheat",
        description: "стабильный клиент с расширенным функционалом созданный модератором ddnet",
        image: "https://i.postimg.cc/W4Gkp0xq/Sta.png",
        download: "https://drive.google.com/file/d/1aL4HRDIPJvvzsQ0IaFM03ymjDmUCvdCJ/view?usp=sharing"
    },
    {
        title: "tclientv3+",
        type: "ddnet cheat",
        badge: "ddnet • cheat",
        description: "старая версия популярного tclient, но с чит функционалом",
        image: "https://i.postimg.cc/7L8zyKty/Tclient-Plus.png",
        download: "https://drive.google.com/file/d/1Z019ZmXcA936aFyiz3Qv65Mx8lYpm_NP/view?usp=sharing",
        arts: ["https://i.postimg.cc/Z5CxchH8/image.png"]
    },
    {
        title: "vbot client",
        type: "teeworlds cheat",
        badge: "teeworlds • cheat",
        description: "чит клиент имеющий бота",
        image: "https://i.postimg.cc/LXmZJnMC/vbot.png",
        download: "https://drive.google.com/file/d/1wyWOSwKvVmb7XYczlA_s9tcBpzsFHspm/view?usp=sharing"
    },
    {
        title: "zyro client",
        type: "ddnet cheat",
        badge: "ddnet • cheat",
        description: "чит клиент, создан для не большой помощи разработчикам в создании новых клиентов",
        image: "https://i.postimg.cc/9M1wZCmW/zyro.png",
        download: "https://drive.google.com/file/d/19rqXCnSE3A1t8-qOwJrn-MB7UedwzrdS/view?usp=sharing"
    },
    {
        title: "cactus client",
        type: "ddnet",
        badge: "ddnet",
        description: "почти такой же клиент как и tclient, но создан на русском языке",
        image: "https://i.postimg.cc/6pdSr5SJ/DDNet-0-FDBKfkq-Sp.png",
        download: "https://drive.google.com/file/d/1T7T110zIphf9PGiXL-5e0H5TWM6SrP6x/view?usp=sharing",
        arts: ["https://i.postimg.cc/J0rbBwtN/image.png"]
    },
    {
        title: "cactus client private",
        type: "ddnet",
        badge: "ddnet",
        description: "тот же cactus client, но крякнутая приватная версия",
        image: "https://i.postimg.cc/W1j9TM9Y/image.png",
        download: "https://drive.google.com/file/d/1SyKu6KNSZIDOl_Psex72ydLy8GrWt4f6/view?usp=sharing",
        arts: ["https://i.postimg.cc/J0rbBwtN/image.png"]
    },
    {
        title: "tater client",
        type: "ddnet",
        badge: "ddnet",
        description: "модификация ddnet клиента со своим визуальным функционалом",
        image: "https://i.postimg.cc/L53Dqn5N/DDNet-Kkrd-PXJh-TN.png",
        download: "https://drive.google.com/file/d/1Edpb1pXB6_WngDM1XhqiGJL4bDGKJ85T/view?usp=sharing",
        arts: ["https://i.postimg.cc/Z5CxchH8/image.png"]
    }
];

let currentGallery = [];
let currentGalleryIndex = 0;
let securityClickCount = 0;
let gravityMode = false;

function renderClients() {
    const grid = document.getElementById('clientsGrid');
    grid.innerHTML = '';

    clientsData.forEach((client, index) => {
        const card = document.createElement('div');
        card.className = 'client-card';
        card.setAttribute('data-type', client.type);
        card.style.animationDelay = `${index * 0.1}s`;

        let artButton = '';
        if (client.arts && client.arts.length > 0) {
            artButton = `
                <button class="card-button art-btn" onclick="openArtGallery(${index})">
                    <i class="fas fa-image"></i> арты
                </button>
            `;
        }

        let downloadButton = '';
        if (client.download) {
            downloadButton = `
                <a href="${client.download}" class="card-button" target="_blank">
                    <i class="fas fa-download"></i> скачать
                </a>
            `;
        } else if (client.buy) {
            downloadButton = `
                <a href="${client.buy}" class="card-button buy-btn" target="_blank">
                    <i class="fas fa-shopping-cart"></i> купить
                </a>
            `;
        }

        card.innerHTML = `
            <div class="card-image-wrapper">
                <img src="${client.image}" alt="${client.title}" class="card-image" loading="lazy">
                <span class="card-badge">${client.badge}</span>
            </div>
            <div class="card-content">
                <h3 class="card-title">${client.title}</h3>
                <p class="card-description">${client.description}</p>
                <div class="card-actions">
                    <button class="card-button preview-btn" onclick="openImageModal('${client.image}')">
                        <i class="fas fa-eye"></i> просмотр
                    </button>
                    ${artButton}
                    ${downloadButton}
                </div>
            </div>
        `;

        grid.appendChild(card);
    });

    initCardTilt();
}

function initCardTilt() {
    const cards = document.querySelectorAll('.client-card, .feature-card, .stat-box, .about-text');
    
    cards.forEach(card => {
        card.addEventListener('mousemove', (e) => {
            if (gravityMode) return;
            
            const rect = card.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            
            const rotateX = (y - centerY) / 10;
            const rotateY = (centerX - x) / 10;
            
            card.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateY(-10px)`;
        });
        
        card.addEventListener('mouseleave', () => {
            if (gravityMode) return;
            card.style.transform = 'perspective(1000px) rotateX(0) rotateY(0) translateY(0)';
        });
    });
}

renderClients();

const canvas = document.getElementById('matrixCanvas');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const matrix = "ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*";
const matrixArray = matrix.split("");
const fontSize = 14;
const columns = Math.floor(canvas.width / fontSize);
const drops = Array(columns).fill(1);

function drawMatrix() {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#ff073a';
    ctx.font = fontSize + 'px monospace';

    for(let i = 0; i < drops.length; i++) {
        const text = matrixArray[Math.floor(Math.random() * matrixArray.length)];
        ctx.fillText(text, i * fontSize, drops[i] * fontSize);

        if(drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
            drops[i] = 0;
        }
        drops[i]++;
    }
}

setInterval(drawMatrix, 50);

function createParticles() {
    const particlesContainer = document.getElementById('heroParticles');
    const particleCount = 25;

    for(let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.left = Math.random() * 100 + '%';
        particle.style.width = Math.random() * 4 + 2 + 'px';
        particle.style.height = particle.style.width;
        particle.style.animationDelay = Math.random() * 15 + 's';
        particle.style.animationDuration = Math.random() * 10 + 20 + 's';
        particlesContainer.appendChild(particle);
    }
}

createParticles();

const cursor = document.getElementById('customCursor');
let mouseX = 0, mouseY = 0;
let cursorX = 0, cursorY = 0;

document.addEventListener('mousemove', (e) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
});

function animateCursor() {
    cursorX += (mouseX - cursorX) * 0.2;
    cursorY += (mouseY - cursorY) * 0.2;
    cursor.style.left = cursorX + 'px';
    cursor.style.top = cursorY + 'px';
    requestAnimationFrame(animateCursor);
}

animateCursor();

document.addEventListener('mousedown', () => {
    cursor.classList.add('clicked');
});

document.addEventListener('mouseup', () => {
    cursor.classList.remove('clicked');
});

window.addEventListener('load', () => {
    setTimeout(() => {
        document.getElementById('loader').classList.add('hidden');
    }, 1500);
});

let lastScroll = 0;
let ticking = false;

window.addEventListener('scroll', () => {
    lastScroll = window.scrollY;
    if (!ticking) {
        window.requestAnimationFrame(() => {
            const header = document.getElementById('navHeader');
            if(lastScroll > 100) {
                header.classList.add('scrolled');
            } else {
                header.classList.remove('scrolled');
            }

            const scrollTop = document.getElementById('scrollTop');
            if(lastScroll > 500) {
                scrollTop.classList.add('visible');
            } else {
                scrollTop.classList.remove('visible');
            }
            ticking = false;
        });
        ticking = true;
    }
});

const menuToggle = document.getElementById('menuToggle');
const navMenu = document.getElementById('navMenu');

menuToggle.addEventListener('click', () => {
    navMenu.classList.toggle('active');
    menuToggle.classList.toggle('active');
});

document.querySelectorAll('a[href^="#"]').forEach(anchor => {
    anchor.addEventListener('click', function(e) {
        e.preventDefault();
        const target = document.querySelector(this.getAttribute('href'));
        if(target) {
            target.scrollIntoView({
                behavior: 'smooth',
                block: 'start'
            });
            navMenu.classList.remove('active');
            menuToggle.classList.remove('active');
        }
    });
});

document.getElementById('scrollTop').addEventListener('click', () => {
    window.scrollTo({
        top: 0,
        behavior: 'smooth'
    });
});

const searchInput = document.getElementById('searchInput');

searchInput.addEventListener('input', (e) => {
    const searchTerm = e.target.value.toLowerCase();
    const grid = document.getElementById('clientsGrid');
    const cards = grid.querySelectorAll('.client-card');

    cards.forEach(card => {
        const title = card.querySelector('.card-title').textContent.toLowerCase();
        const description = card.querySelector('.card-description').textContent.toLowerCase();

        if(title.includes(searchTerm) || description.includes(searchTerm)) {
            card.classList.remove('hidden');
        } else {
            card.classList.add('hidden');
        }
    });
});

const filterButtons = document.querySelectorAll('.filter-pill');

filterButtons.forEach(button => {
    button.addEventListener('click', () => {
        filterButtons.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');

        const filter = button.getAttribute('data-filter');
        const grid = document.getElementById('clientsGrid');
        const cards = grid.querySelectorAll('.client-card');

        cards.forEach(card => {
            if(filter === 'all') {
                card.classList.remove('hidden');
            } else {
                const cardTypes = card.getAttribute('data-type');
                if(cardTypes && cardTypes.includes(filter)) {
                    card.classList.remove('hidden');
                } else {
                    card.classList.add('hidden');
                }
            }
        });
    });
});

function openImageModal(imageSrc) {
    const modal = document.getElementById('imageModal');
    const modalImage = document.getElementById('modalImage');
    modalImage.src = imageSrc;
    modal.classList.add('active');
}

function closeImageModal() {
    const modal = document.getElementById('imageModal');
    modal.classList.remove('active');
}

document.getElementById('imageModal').addEventListener('click', (e) => {
    if(e.target === e.currentTarget) {
        closeImageModal();
    }
});

function openArtGallery(clientIndex) {
    const client = clientsData[clientIndex];
    if (!client.arts || client.arts.length === 0) return;

    currentGallery = client.arts;
    currentGalleryIndex = 0;
    
    const gallery = document.getElementById('artGallery');
    const galleryImage = document.getElementById('galleryImage');
    const indicators = document.getElementById('galleryIndicators');
    
    galleryImage.classList.remove('loaded');
    
    const img = new Image();
    img.onload = function() {
        galleryImage.src = currentGallery[0];
        setTimeout(() => {
            galleryImage.classList.add('loaded');
        }, 50);
    };
    img.src = currentGallery[0];
    
    indicators.innerHTML = '';
    currentGallery.forEach((_, index) => {
        const indicator = document.createElement('div');
        indicator.className = 'gallery-indicator' + (index === 0 ? ' active' : '');
        indicator.addEventListener('click', () => goToGalleryImage(index));
        indicators.appendChild(indicator);
    });
    
    updateGalleryCounter();
    gallery.classList.add('active');
}

function goToGalleryImage(index) {
    currentGalleryIndex = index;
    const galleryImage = document.getElementById('galleryImage');
    
    galleryImage.classList.remove('loaded');
    
    const img = new Image();
    img.onload = function() {
        galleryImage.src = currentGallery[currentGalleryIndex];
        setTimeout(() => {
            galleryImage.classList.add('loaded');
        }, 50);
    };
    img.src = currentGallery[currentGalleryIndex];
    
    document.querySelectorAll('.gallery-indicator').forEach((ind, i) => {
        ind.classList.toggle('active', i === currentGalleryIndex);
    });
    
    updateGalleryCounter();
}

function nextGalleryImage() {
    currentGalleryIndex = (currentGalleryIndex + 1) % currentGallery.length;
    goToGalleryImage(currentGalleryIndex);
}

function prevGalleryImage() {
    currentGalleryIndex = (currentGalleryIndex - 1 + currentGallery.length) % currentGallery.length;
    goToGalleryImage(currentGalleryIndex);
}

function updateGalleryCounter() {
    const counter = document.getElementById('galleryCounter');
    counter.textContent = `${currentGalleryIndex + 1} / ${currentGallery.length}`;
}

function closeArtGallery() {
    document.getElementById('artGallery').classList.remove('active');
}

document.getElementById('galleryNext').addEventListener('click', nextGalleryImage);
document.getElementById('galleryPrev').addEventListener('click', prevGalleryImage);
document.getElementById('galleryClose').addEventListener('click', closeArtGallery);

document.getElementById('artGallery').addEventListener('click', (e) => {
    if(e.target === e.currentTarget) {
        closeArtGallery();
    }
});

document.addEventListener('keydown', (e) => {
    if(e.key === 'Escape') {
        closeImageModal();
        closeArtGallery();
    }
    if(document.getElementById('artGallery').classList.contains('active')) {
        if(e.key === 'ArrowRight') nextGalleryImage();
        if(e.key === 'ArrowLeft') prevGalleryImage();
    }
});

const counters = document.querySelectorAll('.stat-number');
let hasAnimated = false;

function animateCounters() {
    counters.forEach(counter => {
        const target = parseInt(counter.getAttribute('data-count'));
        const duration = 2000;
        const increment = target / (duration / 16);
        let current = 0;

        const updateCounter = () => {
            current += increment;
            if(current < target) {
                counter.textContent = Math.floor(current);
                requestAnimationFrame(updateCounter);
            } else {
                counter.textContent = target;
            }
        };

        updateCounter();
    });
}

const statsSection = document.getElementById('stats');
const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if(entry.isIntersecting && !hasAnimated) {
            animateCounters();
            hasAnimated = true;
        }
    });
}, { threshold: 0.5 });

if(statsSection) {
    observer.observe(statsSection);
}

const securityIcon = document.getElementById('securityIcon');
securityIcon.addEventListener('click', () => {
    securityClickCount++;
    
    if (securityClickCount === 3) {
        activateGravityMode();
        securityClickCount = 0;
    }
    
    setTimeout(() => {
        securityClickCount = 0;
    }, 2000);
});

function activateGravityMode() {
    if (gravityMode) return;
    gravityMode = true;
    
    document.body.classList.add('gravity-mode');
    
    const Engine = Matter.Engine;
    const Render = Matter.Render;
    const World = Matter.World;
    const Bodies = Matter.Bodies;
    const Mouse = Matter.Mouse;
    const MouseConstraint = Matter.MouseConstraint;
    
    const physicsCanvas = document.getElementById('physicsCanvas');
    physicsCanvas.classList.add('active');
    
    const engine = Engine.create();
    const world = engine.world;
    
    const render = Render.create({
        canvas: physicsCanvas,
        engine: engine,
        options: {
            width: window.innerWidth,
            height: window.innerHeight,
            wireframes: false,
            background: 'transparent'
        }
    });
    
    const ground = Bodies.rectangle(
        window.innerWidth / 2, 
        window.innerHeight + 50, 
        window.innerWidth * 2, 
        100, 
        { isStatic: true }
    );
    
    const leftWall = Bodies.rectangle(-50, window.innerHeight / 2, 100, window.innerHeight * 2, { isStatic: true });
    const rightWall = Bodies.rectangle(window.innerWidth + 50, window.innerHeight / 2, 100, window.innerHeight * 2, { isStatic: true });
    
    World.add(world, [ground, leftWall, rightWall]);
    
    const elements = document.querySelectorAll('.client-card, .feature-card, .stat-box, .about-text, .logo-text, .nav-link, .section-title');
    
    elements.forEach(el => {
        const rect = el.getBoundingClientRect();
        
        const body = Bodies.rectangle(
            rect.left + rect.width / 2,
            rect.top + rect.height / 2,
            rect.width,
            rect.height,
            {
                restitution: 0.6,
                friction: 0.05,
                render: {
                    fillStyle: 'rgba(255, 7, 58, 0.2)',
                    strokeStyle: '#ff073a',
                    lineWidth: 2
                }
            }
        );
        
        World.add(world, body);
        
        el.style.position = 'fixed';
        el.style.zIndex = '999999';
        
        Matter.Events.on(engine, 'afterUpdate', () => {
            el.style.top = `${body.position.y - rect.height / 2}px`;
            el.style.left = `${body.position.x - rect.width / 2}px`;
            el.style.transform = `rotate(${body.angle}rad)`;
        });
    });
    
    const mouse = Mouse.create(render.canvas);
    const mouseConstraint = MouseConstraint.create(engine, {
        mouse: mouse,
        constraint: {
            stiffness: 0.2,
            render: {
                visible: false
            }
        }
    });
    
    World.add(world, mouseConstraint);
    render.mouse = mouse;
    
    Engine.run(engine);
    Render.run(render);
}

let resizeTimeout;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }, 250);
});
