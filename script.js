const clientsData = [
    {
        title: "ae86 client vae5",
        type: "teeworlds cheat",
        badge: "teeworlds • cheat",
        description: "модифицированная версия sash client от русского разработчика с улучшенным функционалом",
        image: "https://i.postimg.cc/L5XYVw5j/Ae86-Client-b-Rsph-Qx-Yd-C.png",
        download: "https://drive.google.com/file/d/1kc2a6ccX0Io4x4Y4pkcFbGn4ihAsufLU/view?usp=sharing",
        arts: [
            "https://i.postimg.cc/TYjz6nvn/image.png",
            "https://i.postimg.cc/kMKZQWGt/image.png",
            "https://i.postimg.cc/MTRsY8WL/image.png",
            "https://i.postimg.cc/Qdt0y78g/image.png"
        ]
    },
    {
        title: "ae86 client vae6 beta",
        type: "teeworlds cheat",
        badge: "ddnet • cheat",
        description: "новая бета версия клиента ae86 client",
        image: "https://i.postimg.cc/TPX4yVND/image.png",
        download: "https://drive.google.com/file/d/1d8EPjCQTdrJj4llGI2QUwnim8d97arUk/view?usp=sharing",
        arts: [
            "https://i.postimg.cc/TYjz6nvn/image.png",
            "https://i.postimg.cc/kMKZQWGt/image.png",
            "https://i.postimg.cc/MTRsY8WL/image.png",
            "https://i.postimg.cc/Qdt0y78g/image.png"
        ]
    },
    {
        title: "dd.cff client",
        type: "ddnet cheat",
        badge: "ddnet • cheat",
        description: "мощный клиент для ddnet с отличным чит функционалом",
        image: "https://i.postimg.cc/G2v8F0C2/77CC8FC6-1104-4999-8425-9563957F3F83.png",
        download: "https://drive.google.com/file/d/1IqiywkybJ6HeqPjO6fIDHnQ11qM-VVQ5/view?usp=sharing",
        arts: ["https://i.postimg.cc/9FGhQvZy/image.png"]
    },
    {
        title: "goreworlds client",
        type: "teeworlds",
        badge: "teeworlds",
        description: "клиент имеющий 16+ отметку так как имеет кровь и другие вещи",
        image: "https://i.postimg.cc/158VnkLQ/Goreworlds-g27du-XIFXy.png",
        download: "https://drive.google.com/file/d/1yF6pZtd9w4x7-uNlRMlN2sDPLAP7aJgc/view?usp=sharing"
    },
    {
        title: "nn client crack",
        type: "ddnet",
        badge: "ddnet • cheat",
        description: "похож на tclientv3 plus, но улучшенный функционал",
        image: "https://i.postimg.cc/B6gS75VW/image.png",
        download: "https://drive.google.com/file/d/1ckCVIP2HAZPDuPsqcsEWJdcTkOnUMuHk/view?usp=sharing"
    },
    {
        title: "sash upgradev32",
        type: "teeworlds cheat",
        badge: "teeworlds • cheat",
        description: "обновленная версия популярного клиента sash",
        image: "https://i.postimg.cc/9QGYfLgC/DDNet-f-FKHEV6m-BU.png",
        download: "https://drive.google.com/file/d/1dj57EspAJG3SepJtIx33RY4-R7jiSlhm/view?usp=sharing",
        arts: ["https://i.postimg.cc/nrp1YjSJ/image.png"]
    },
    {
        title: "saiko",
        type: "teeworlds cheat",
        badge: "ddnet • cheat",
        description: "tclient, но с avoid freeze функционалом саппорт",
        image: "https://i.postimg.cc/CxpZ956N/image.png",
        download: "https://drive.google.com/file/d/1OBtyT__yH9MmuFxgcddySd5B2I3EfTL3/view?usp=sharing"
    },
    {
        title: "MRXClient",
        type: "ddnet cheat",
        badge: "ddnet • cheat",
        description: "клиентик для тех кто любит не палиться и новайс мапы",
        image: "https://i.postimg.cc/ZRPHGG4q/izobrazenie.png",
        download: "https://drive.google.com/file/d/12gKIkI7XXIhgmpNRsxM9-74HrIx1aT5k/view?usp=sharing"
    },
    {
        title: "Ae86 Client vAe4",
        type: "teeworlds cheat",
        badge: "teeworlds • cheat",
        description: "старая версия Ae86 Client",
        image: "https://i.postimg.cc/q7yW7Zpq/izobrazenie.png",
        download: "https://drive.google.com/file/d/1Q-cdqeR3igj8D1Lm40_OLaOuo43a53Ak/view?usp=drive_link",
        arts: [
            "https://i.postimg.cc/TYjz6nvn/image.png",
            "https://i.postimg.cc/kMKZQWGt/image.png",
            "https://i.postimg.cc/MTRsY8WL/image.png",
            "https://i.postimg.cc/Qdt0y78g/image.png"
        ]
    },
    {
        title: "KoshkaClient",
        type: "ddnet",
        badge: "ddnet",
        description: "легит клиент от создателя KotClient'а",
        image: "https://i.postimg.cc/6QxWbjw5/izobrazenie.png",
        download: "https://drive.google.com/file/d/1I7bUk7DFVcEd8MUL6sCXtgvjmx5Fk_3I/view?usp=sharing"
    },
    {
        title: "KotClient",
        type: "ddnet cheat",
        badge: "ddnet • cheat",
        description: "нью клиент, все так же похож на saiko, но функционал гораздо лучше",
        image: "https://i.postimg.cc/0jLGTvM0/izobrazenie.png",
        telegram: "https://t.me/KotClient",
        arts: [
            "https://i.postimg.cc/gkFJqPzF/photo-2025-12-03-12-14-23.jpg",
            "https://i.postimg.cc/6pRk5Gtr/izobrazenie%281%29.jpg",
            "https://i.postimg.cc/DzPR1kWr/izobrazenie%282%29.png"
        ]
    },
    {
        title: "soup",
        type: "teeworlds cheat",
        badge: "ddnet • cheat",
        description: "копирка saiko, но с более улучшенным авойдом. Подойдет для легитов",
        image: "https://i.postimg.cc/fyHYYktn/izobrazenie.png",
        download: "https://drive.google.com/file/d/1m4_s9OnHBNlhoYIaKygvQutLbbKy3ucS/view?usp=sharing",
        discord: "https://discord.gg/ECeDVAEVJn"
    },
    {
        title: "sakura client",
        type: "ddnet",
        badge: "ddnet",
        description: "элегантный клиент с уникальным дизайном",
        image: "https://i.postimg.cc/YCT1ndNg/DDNet-Nvq-Le-PTl3l.png",
        download: "https://drive.google.com/file/d/1dAN7qLy7EBhL5fpjM2Q3dgUNOO-o7bYl/view?usp=sharing"
    },
    {
        title: "sash by akrd1337",
        type: "teeworlds cheat",
        badge: "teeworlds • cheat",
        description: "модифицированная версия sash клиента",
        image: "https://i.postimg.cc/RF0yrWQr/Sash-crack-9-Bk-Px-GRpz-A.png",
        download: "https://drive.google.com/file/d/1TZLt4QWUcG5BXxzw4_BLi4f6yJMbs3hQ/view?usp=sharing",
        arts: ["https://i.postimg.cc/nrp1YjSJ/image.png"]
    },
    {
        title: "jimjam client",
        type: "teeworlds",
        badge: "teeworlds",
        description: "прикольный клиент, в нем есть много разных полезных функций",
        image: "https://i.postimg.cc/HWZ7LYvz/jimjam.png",
        download: "https://drive.google.com/file/d/1_o3R3FQs3Jv3ARDJKz2EslMxJLbZPJZG/view?usp=sharing"
    },
    {
        title: "k-client",
        type: "teeworlds cheat",
        badge: "teeworlds • cheat",
        description: "клиент похожий на krx, но на teeworlds",
        image: "https://i.postimg.cc/HxtXzb21/K-Client-ENFC6b2kks.png",
        download: "https://drive.google.com/file/d/1CknKAMSTwWoU3OlPwMacin0mqfAaBiRY/view?usp=sharing"
    },
    {
        title: "krx client crack 1.32",
        type: "ddnet cheat",
        badge: "ddnet • cheat • premium",
        description: "крякнутая версия krx клиента 1.32 с рабочим когом",
        image: "https://i.postimg.cc/RhVfDqs6/KRX-Client-1-32.png",
        buy: "https://t.me/Doibronetri",
        arts: [
            "https://i.postimg.cc/kgb7KB0Q/image.png",
            "https://i.postimg.cc/VNFQWMD5/image.png"
        ]
    },
    {
        title: "krx client 1.32 crack",
        type: "ddnet",
        badge: "ddnet • cheat • crack",
        description: "кряк крякнутой версия krx клиента 1.32, но не рабочим когом пароль от архива: 1",
        image: "https://i.postimg.cc/25c5w7b1/image.png",
        download: "https://drive.google.com/file/d/1DlHPGvhOozqGMM2PliZKBgY6QtD4jjvU/view?usp=sharing",
        arts: [
            "https://i.postimg.cc/kgb7KB0Q/image.png",
            "https://i.postimg.cc/VNFQWMD5/image.png"
        ]
    },
    {
        title: "mario client",
        type: "teeworlds",
        badge: "teeworlds",
        description: "тематический клиент с одной функции которая добавляет визуального mario на сервер",
        image: "https://i.postimg.cc/qMqych6W/mario.png",
        download: "https://drive.google.com/file/d/1wrDlSev7R_3c33wP87tXaFD2dLireEL-/view?usp=sharing"
    },
    {
        title: "dperx",
        type: "ddnet",
        badge: "ddnet • cheat",
        description: "не совсем клиент. Инжектиться в сам дднет и добавляет чит через него",
        image: "https://i.postimg.cc/yNZq5Z7K/izobrazenie.png",
        download: "https://github.com/kiocode/DPerX-Reborn/releases/download/1.1.4/dperx-reborn-1.1.4-setup.exe"
    },
    {
        title: "pulse client",
        type: "ddnet",
        badge: "ddnet",
        description: "новый клиент сильно вдохновленный cactus client'ом",
        image: "https://i.postimg.cc/Pf218zJm/pulse-client.png",
        download: "https://drive.google.com/file/d/100huDXqIS2xmbM1vxAi3YCM_UjxInq8l/view?usp=sharing"
    },
    {
        title: "s-client",
        type: "teeworlds",
        badge: "teeworlds",
        description: "клиент похожий на tclient, но на teewoorlds",
        image: "https://i.postimg.cc/d3HdPvpW/S-Client-Ys-E8k9f-B1w.png",
        download: "https://drive.google.com/file/d/1bUL49r3GTPZInQUZx-fr_WtNmaEanUU4/view?usp=sharing"
    },
    {
        title: "sqclient",
        type: "ddnet cheat",
        badge: "ddnet • cheat",
        description: "новый чит клиент, а точнее его крякнутая версия модификация tclient, но с читами",
        image: "https://i.postimg.cc/vZ6njJzz/SQClient.png",
        download: "https://drive.google.com/file/d/1nAvrsid6ZItkiCzBzBcDToCNjskj5pnC/view?usp=sharing"
    },
    {
        title: "sta client",
        type: "teeworlds cheat",
        badge: "teeworlds • cheat",
        description: "стабильный клиент с расширенным функционалом созданный модератором ddnet",
        image: "https://i.postimg.cc/W4Gkp0xq/Sta.png",
        download: "https://drive.google.com/file/d/1aL4HRDIPJvvzsQ0IaFM03ymjDmUCvdCJ/view?usp=sharing"
    },
    {
        title: "tclientv3+",
        type: "ddnet cheat",
        badge: "ddnet • cheat",
        description: "старая версия популярного tclient, но с чит функционалом",
        image: "https://i.postimg.cc/7L8zyKty/Tclient-Plus.png",
        download: "https://drive.google.com/file/d/1Z019ZmXcA936aFyiz3Qv65Mx8lYpm_NP/view?usp=sharing",
        arts: ["https://i.postimg.cc/Z5CxchH8/image.png"]
    },
    {
        title: "vbot client",
        type: "teeworlds cheat",
        badge: "teeworlds • cheat",
        description: "чит клиент имеющий бота",
        image: "https://i.postimg.cc/LXmZJnMC/vbot.png",
        download: "https://drive.google.com/file/d/1wyWOSwKvVmb7XYczlA_s9tcBpzsFHspm/view?usp=sharing"
    },
    {
        title: "zyro client",
        type: "ddnet cheat",
        badge: "ddnet • cheat",
        description: "чит клиент, создан для не большой помощи разработчикам в создании новых клиентов",
        image: "https://i.postimg.cc/9M1wZCmW/zyro.png",
        download: "https://drive.google.com/file/d/19rqXCnSE3A1t8-qOwJrn-MB7UedwzrdS/view?usp=sharing"
    },
    {
        title: "cactus client",
        type: "ddnet",
        badge: "ddnet",
        description: "почти такой же клиент как и tclient, но создан на русском языке",
        image: "https://i.postimg.cc/6pdSr5SJ/DDNet-0-FDBKfkq-Sp.png",
        download: "https://drive.google.com/file/d/1T7T110zIphf9PGiXL-5e0H5TWM6SrP6x/view?usp=sharing",
        arts: ["https://i.postimg.cc/J0rbBwtN/image.png"]
    },
    {
        title: "cactus client private",
        type: "ddnet",
        badge: "ddnet",
        description: "тот же cactus client, но крякнутая приватная версия",
        image: "https://i.postimg.cc/W1j9TM9Y/image.png",
        download: "https://drive.google.com/file/d/1SyKu6KNSZIDOl_Psex72ydLy8GrWt4f6/view?usp=sharing",
        arts: ["https://i.postimg.cc/J0rbBwtN/image.png"]
    },
    {
        title: "tater client",
        type: "ddnet",
        badge: "ddnet",
        description: "модификация ddnet клиента со своим визуальным функционалом",
        image: "https://i.postimg.cc/L53Dqn5N/DDNet-Kkrd-PXJh-TN.png",
        download: "https://drive.google.com/file/d/1Edpb1pXB6_WngDM1XhqiGJL4bDGKJ85T/view?usp=sharing",
        arts: ["https://i.postimg.cc/Z5CxchH8/image.png"]
    }
];

let currentGallery = [];
let currentGalleryIndex = 0;
let securityClickCount = 0;
let gravityMode = false;
let matrixAnimationId = null;
let isMatrixRunning = false;

const debounce = (func, wait) => {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
};

function renderClients() {
    const grid = document.getElementById('clientsGrid');
    if (!grid) return;
    
    const fragment = document.createDocumentFragment();
    
    clientsData.forEach((client, index) => {
        const card = document.createElement('div');
        card.className = 'client-card';
        card.setAttribute('data-type', client.type);
        card.style.setProperty('--card-index', index);
        
        let artButton = '';
        if (client.arts && client.arts.length > 0) {
            artButton = `
                <button class="card-button art-btn" onclick="openArtGallery(${index})">
                    <i class="fas fa-image"></i> арты
                </button>
            `;
        }
        
        let discordButton = '';
        if (client.discord) {
            discordButton = `
                <a href="${client.discord}" class="card-button discord-btn" target="_blank" rel="noopener">
                    <i class="fab fa-discord"></i> discord
                </a>
            `;
        }
        
        let telegramButton = '';
        if (client.telegram) {
            telegramButton = `
                <a href="${client.telegram}" class="card-button telegram-btn" target="_blank" rel="noopener">
                    <i class="fab fa-telegram"></i> telegram
                </a>
            `;
        }
        
        let downloadButton = '';
        if (client.download) {
            downloadButton = `
                <a href="${client.download}" class="card-button" target="_blank" rel="noopener">
                    <i class="fas fa-download"></i> скачать
                </a>
            `;
        } else if (client.buy) {
            downloadButton = `
                <a href="${client.buy}" class="card-button buy-btn" target="_blank" rel="noopener">
                    <i class="fas fa-shopping-cart"></i> купить
                </a>
            `;
        }
        
        card.innerHTML = `
            <div class="card-image-wrapper">
                <img src="${client.image}" alt="${client.title}" class="card-image" loading="lazy">
                <span class="card-badge">${client.badge}</span>
            </div>
            <div class="card-content">
                <h3 class="card-title">${client.title}</h3>
                <p class="card-description">${client.description}</p>
                <div class="card-actions">
                    <button class="card-button preview-btn" onclick="openImageModal('${client.image}')">
                        <i class="fas fa-eye"></i> просмотр
                    </button>
                    ${artButton}
                    ${discordButton}
                    ${telegramButton}
                    ${downloadButton}
                </div>
            </div>
        `;
        
        fragment.appendChild(card);
    });
    
    grid.innerHTML = '';
    grid.appendChild(fragment);
    
    if (window.innerWidth > 768) {
        requestAnimationFrame(() => {
            initCardTilt();
        });
    }
}

function initCardTilt() {
    if ('ontouchstart' in window) return;
    
    const cards = document.querySelectorAll('.client-card, .feature-card, .stat-box, .about-text');
    
    cards.forEach(card => {
        const handleMouseMove = (e) => {
            if (gravityMode) return;
            
            const rect = card.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            
            const rotateX = (y - centerY) / 10;
            const rotateY = (centerX - x) / 10;
            
            card.style.transform = `perspective(1000px) rotateX(${rotateX}deg) rotateY(${rotateY}deg) translateY(-10px)`;
        };
        
        const handleMouseLeave = () => {
            if (gravityMode) return;
            card.style.transform = 'perspective(1000px) rotateX(0) rotateY(0) translateY(0)';
        };
        
        card.addEventListener('mousemove', handleMouseMove, { passive: true });
        card.addEventListener('mouseleave', handleMouseLeave, { passive: true });
    });
}

const canvas = document.getElementById('matrixCanvas');
const ctx = canvas?.getContext('2d');

function initMatrix() {
    if (!canvas || !ctx) return;
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    const matrix = "ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*";
    const matrixArray = matrix.split("");
    const fontSize = 14;
    const columns = Math.floor(canvas.width / fontSize);
    const drops = Array(columns).fill(1);
    
    function drawMatrix() {
        if (!isMatrixRunning) return;
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#ff073a';
        ctx.font = fontSize + 'px monospace';
        
        for(let i = 0; i < drops.length; i++) {
            const text = matrixArray[Math.floor(Math.random() * matrixArray.length)];
            ctx.fillText(text, i * fontSize, drops[i] * fontSize);
            
            if(drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                drops[i] = 0;
            }
            drops[i]++;
        }
        
        matrixAnimationId = requestAnimationFrame(drawMatrix);
    }
    
    isMatrixRunning = true;
    drawMatrix();
}

function createParticles() {
    const particlesContainer = document.getElementById('heroParticles');
    if (!particlesContainer) return;
    
    const fragment = document.createDocumentFragment();
    const particleCount = window.innerWidth > 768 ? 25 : 15;
    
    for(let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.left = Math.random() * 100 + '%';
        particle.style.width = Math.random() * 4 + 2 + 'px';
        particle.style.height = particle.style.width;
        particle.style.animationDelay = Math.random() * 15 + 's';
        particle.style.animationDuration = Math.random() * 10 + 20 + 's';
        fragment.appendChild(particle);
    }
    
    particlesContainer.appendChild(fragment);
}

if (window.innerWidth > 768 && window.matchMedia('(hover: hover)').matches) {
    const cursor = document.getElementById('customCursor');
    if (cursor) {
        let mouseX = 0, mouseY = 0;
        let cursorX = 0, cursorY = 0;
        let rafId = null;
        
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        function animateCursor() {
            const dx = mouseX - cursorX;
            const dy = mouseY - cursorY;
            
            cursorX += dx * 0.2;
            cursorY += dy * 0.2;
            
            cursor.style.left = cursorX + 'px';
            cursor.style.top = cursorY + 'px';
            
            rafId = requestAnimationFrame(animateCursor);
        }
        
        animateCursor();
        
        document.addEventListener('mousedown', () => cursor.classList.add('clicked'));
        document.addEventListener('mouseup', () => cursor.classList.remove('clicked'));
    }
}

window.addEventListener('load', () => {
    setTimeout(() => {
        const loader = document.getElementById('loader');
        if (loader) {
            loader.classList.add('hidden');
            setTimeout(() => {
                loader.style.display = 'none';
            }, 800);
        }
    }, 1000);
    
    renderClients();
    createParticles();
    initMatrix();
});

const handleScroll = debounce(() => {
    const scrollY = window.scrollY;
    const header = document.getElementById('navHeader');
    const scrollTop = document.getElementById('scrollTop');
    
    if (header) {
        if(scrollY > 100) {
            header.classList.add('scrolled');
        } else {
            header.classList.remove('scrolled');
        }
    }
    
    if (scrollTop) {
        if(scrollY > 500) {
            scrollTop.classList.add('visible');
        } else {
            scrollTop.classList.remove('visible');
        }
    }
}, 10);

window.addEventListener('scroll', handleScroll, { passive: true });

const menuToggle = document.getElementById('menuToggle');
const navMenu = document.getElementById('navMenu');

if (menuToggle && navMenu) {
    menuToggle.addEventListener('click', () => {
        navMenu.classList.toggle('active');
        menuToggle.classList.toggle('active');
    });
}

document.querySelectorAll('a[href^="#"]').forEach(anchor => {
    anchor.addEventListener('click', function(e) {
        e.preventDefault();
        const targetId = this.getAttribute('href');
        const target = document.querySelector(targetId);
        
        if(target) {
            const headerHeight = document.getElementById('navHeader').offsetHeight;
            const targetPosition = target.offsetTop - headerHeight;
            
            window.scrollTo({
                top: targetPosition,
                behavior: 'smooth'
            });
            
            if (navMenu && menuToggle) {
                navMenu.classList.remove('active');
                menuToggle.classList.remove('active');
            }
        }
    });
});

const scrollTopBtn = document.getElementById('scrollTop');
if (scrollTopBtn) {
    scrollTopBtn.addEventListener('click', () => {
        window.scrollTo({
            top: 0,
            behavior: 'smooth'
        });
    });
}

const searchInput = document.getElementById('searchInput');
if (searchInput) {
    const handleSearch = debounce((e) => {
        const searchTerm = e.target.value.toLowerCase();
        const cards = document.querySelectorAll('.client-card');
        
        cards.forEach(card => {
            const title = card.querySelector('.card-title')?.textContent.toLowerCase() || '';
            const description = card.querySelector('.card-description')?.textContent.toLowerCase() || '';
            
            if(title.includes(searchTerm) || description.includes(searchTerm)) {
                card.classList.remove('hidden');
            } else {
                card.classList.add('hidden');
            }
        });
    }, 300);
    
    searchInput.addEventListener('input', handleSearch);
}

const filterButtons = document.querySelectorAll('.filter-pill');
filterButtons.forEach(button => {
    button.addEventListener('click', () => {
        filterButtons.forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        
        const filter = button.getAttribute('data-filter');
        const cards = document.querySelectorAll('.client-card');
        
        cards.forEach(card => {
            if(filter === 'all') {
                card.classList.remove('hidden');
            } else {
                const cardTypes = card.getAttribute('data-type');
                if(cardTypes && cardTypes.includes(filter)) {
                    card.classList.remove('hidden');
                } else {
                    card.classList.add('hidden');
                }
            }
        });
    });
});

function openImageModal(imageSrc) {
    const modal = document.getElementById('imageModal');
    const modalImage = document.getElementById('modalImage');
    
    if (modal && modalImage) {
        modalImage.src = imageSrc;
        modal.classList.add('active');
        document.body.style.overflow = 'hidden';
    }
}

function closeImageModal() {
    const modal = document.getElementById('imageModal');
    
    if (modal) {
        modal.classList.remove('active');
        document.body.style.overflow = '';
    }
}

window.closeImageModal = closeImageModal;
window.openImageModal = openImageModal;

const imageModal = document.getElementById('imageModal');
if (imageModal) {
    imageModal.addEventListener('click', (e) => {
        if(e.target === e.currentTarget) {
            closeImageModal();
        }
    });
}

function openArtGallery(clientIndex) {
    const client = clientsData[clientIndex];
    if (!client.arts || client.arts.length === 0) return;
    
    currentGallery = client.arts;
    currentGalleryIndex = 0;
    
    const gallery = document.getElementById('artGallery');
    const galleryImage = document.getElementById('galleryImage');
    const indicators = document.getElementById('galleryIndicators');
    
    if (!gallery || !galleryImage || !indicators) return;
    
    galleryImage.classList.remove('loaded');
    
    const img = new Image();
    img.onload = function() {
        galleryImage.src = currentGallery[0];
        setTimeout(() => {
            galleryImage.classList.add('loaded');
        }, 50);
    };
    img.src = currentGallery[0];
    
    indicators.innerHTML = '';
    currentGallery.forEach((_, index) => {
        const indicator = document.createElement('div');
        indicator.className = 'gallery-indicator' + (index === 0 ? ' active' : '');
        indicator.addEventListener('click', () => goToGalleryImage(index));
        indicators.appendChild(indicator);
    });
    
    updateGalleryCounter();
    gallery.classList.add('active');
    document.body.style.overflow = 'hidden';
}

function goToGalleryImage(index) {
    currentGalleryIndex = index;
    const galleryImage = document.getElementById('galleryImage');
    
    if (!galleryImage) return;
    
    galleryImage.classList.remove('loaded');
    
    const img = new Image();
    img.onload = function() {
        galleryImage.src = currentGallery[currentGalleryIndex];
        setTimeout(() => {
            galleryImage.classList.add('loaded');
        }, 50);
    };
    img.src = currentGallery[currentGalleryIndex];
    
    document.querySelectorAll('.gallery-indicator').forEach((ind, i) => {
        ind.classList.toggle('active', i === currentGalleryIndex);
    });
    
    updateGalleryCounter();
}

function nextGalleryImage() {
    currentGalleryIndex = (currentGalleryIndex + 1) % currentGallery.length;
    goToGalleryImage(currentGalleryIndex);
}

function prevGalleryImage() {
    currentGalleryIndex = (currentGalleryIndex - 1 + currentGallery.length) % currentGallery.length;
    goToGalleryImage(currentGalleryIndex);
}

function updateGalleryCounter() {
    const counter = document.getElementById('galleryCounter');
    if (counter) {
        counter.textContent = `${currentGalleryIndex + 1} / ${currentGallery.length}`;
    }
}

function closeArtGallery() {
    const gallery = document.getElementById('artGallery');
    if (gallery) {
        gallery.classList.remove('active');
        document.body.style.overflow = '';
    }
}

window.openArtGallery = openArtGallery;

const galleryNext = document.getElementById('galleryNext');
const galleryPrev = document.getElementById('galleryPrev');
const galleryClose = document.getElementById('galleryClose');
const artGallery = document.getElementById('artGallery');

if (galleryNext) galleryNext.addEventListener('click', nextGalleryImage);
if (galleryPrev) galleryPrev.addEventListener('click', prevGalleryImage);
if (galleryClose) galleryClose.addEventListener('click', closeArtGallery);

if (artGallery) {
    artGallery.addEventListener('click', (e) => {
        if(e.target === e.currentTarget) {
            closeArtGallery();
        }
    });
}

document.addEventListener('keydown', (e) => {
    if(e.key === 'Escape') {
        closeImageModal();
        closeArtGallery();
    }
    if(document.getElementById('artGallery')?.classList.contains('active')) {
        if(e.key === 'ArrowRight') nextGalleryImage();
        if(e.key === 'ArrowLeft') prevGalleryImage();
    }
});

const counters = document.querySelectorAll('.stat-number');
let hasAnimated = false;

function animateCounters() {
    counters.forEach(counter => {
        const target = parseInt(counter.getAttribute('data-count'));
        const duration = 2000;
        const increment = target / (duration / 16);
        let current = 0;
        
        const updateCounter = () => {
            current += increment;
            if(current < target) {
                counter.textContent = Math.floor(current);
                requestAnimationFrame(updateCounter);
            } else {
                counter.textContent = target;
            }
        };
        
        updateCounter();
    });
}

const statsSection = document.getElementById('stats');
if (statsSection) {
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if(entry.isIntersecting && !hasAnimated) {
                animateCounters();
                hasAnimated = true;
                observer.unobserve(entry.target);
            }
        });
    }, { threshold: 0.3 });
    
    observer.observe(statsSection);
}

const securityIcon = document.getElementById('securityIcon');
if (securityIcon) {
    securityIcon.addEventListener('click', () => {
        securityClickCount++;
        
        if (securityClickCount === 3) {
            activateGravityMode();
            securityClickCount = 0;
        }
        
        setTimeout(() => {
            securityClickCount = 0;
        }, 2000);
    });
}

function activateGravityMode() {
    if (gravityMode || !window.Matter) return;
    gravityMode = true;
    
    document.body.classList.add('gravity-mode');
    
    const Engine = Matter.Engine;
    const Render = Matter.Render;
    const World = Matter.World;
    const Bodies = Matter.Bodies;
    const Mouse = Matter.Mouse;
    const MouseConstraint = Matter.MouseConstraint;
    
    const physicsCanvas = document.getElementById('physicsCanvas');
    if (!physicsCanvas) return;
    
    physicsCanvas.classList.add('active');
    
    const engine = Engine.create();
    const world = engine.world;
    
    const render = Render.create({
        canvas: physicsCanvas,
        engine: engine,
        options: {
            width: window.innerWidth,
            height: window.innerHeight,
            wireframes: false,
            background: 'transparent'
        }
    });
    
    const ground = Bodies.rectangle(
        window.innerWidth / 2, 
        window.innerHeight + 50, 
        window.innerWidth * 2, 
        100, 
        { isStatic: true }
    );
    
    const leftWall = Bodies.rectangle(-50, window.innerHeight / 2, 100, window.innerHeight * 2, { isStatic: true });
    const rightWall = Bodies.rectangle(window.innerWidth + 50, window.innerHeight / 2, 100, window.innerHeight * 2, { isStatic: true });
    
    World.add(world, [ground, leftWall, rightWall]);
    
    const elements = document.querySelectorAll('.client-card, .feature-card, .stat-box, .about-text, .logo-text, .nav-link, .section-title');
    
    elements.forEach(el => {
        const rect = el.getBoundingClientRect();
        
        const body = Bodies.rectangle(
            rect.left + rect.width / 2,
            rect.top + rect.height / 2,
            rect.width,
            rect.height,
            {
                restitution: 0.6,
                friction: 0.05,
                render: {
                    fillStyle: 'rgba(255, 7, 58, 0.2)',
                    strokeStyle: '#ff073a',
                    lineWidth: 2
                }
            }
        );
        
        World.add(world, body);
        
        el.style.position = 'fixed';
        el.style.zIndex = '999999';
        
        Matter.Events.on(engine, 'afterUpdate', () => {
            el.style.top = `${body.position.y - rect.height / 2}px`;
            el.style.left = `${body.position.x - rect.width / 2}px`;
            el.style.transform = `rotate(${body.angle}rad)`;
        });
    });
    
    const mouse = Mouse.create(render.canvas);
    const mouseConstraint = MouseConstraint.create(engine, {
        mouse: mouse,
        constraint: {
            stiffness: 0.2,
            render: {
                visible: false
            }
        }
    });
    
    World.add(world, mouseConstraint);
    render.mouse = mouse;
    
    Engine.run(engine);
    Render.run(render);
}

const resizeHandler = debounce(() => {
    if (canvas && ctx) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        if (isMatrixRunning) {
            cancelAnimationFrame(matrixAnimationId);
            initMatrix();
        }
    }
}, 250);

window.addEventListener('resize', resizeHandler, { passive: true });

document.addEventListener('visibilitychange', () => {
    if (document.hidden) {
        isMatrixRunning = false;
        if (matrixAnimationId) {
            cancelAnimationFrame(matrixAnimationId);
        }
    } else {
        if (!isMatrixRunning) {
            initMatrix();
        }
    }
});

if ('IntersectionObserver' in window) {
    const lazyImages = document.querySelectorAll('img[loading="lazy"]');
    const imageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                const img = entry.target;
                img.removeAttribute('loading');
                imageObserver.unobserve(img);
            }
        });
    });
    
    lazyImages.forEach(img => imageObserver.observe(img));
}
