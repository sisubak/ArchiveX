const clientsData = [
    {
        title: "ae86 client vae5",
        type: "teeworlds cheat",
        badge: "teeworlds • cheat",
        description: "modified version of sash client from a Russian developer with improved functionality",
        image: "https://i.postimg.cc/L5XYVw5j/Ae86-Client-b-Rsph-Qx-Yd-C.png",
        download: "https://drive.google.com/file/d/1kc2a6ccX0Io4x4Y4pkcFbGn4ihAsufLU/view?usp=sharing",
        arts: [
            "https://i.postimg.cc/TYjz6nvn/image.png",
            "https://i.postimg.cc/kMKZQWGt/image.png",
            "https://i.postimg.cc/MTRsY8WL/image.png",
            "https://i.postimg.cc/Qdt0y78g/image.png"
        ]
    },
    {
        title: "krx client 1.32 crack",
        type: "ddnet",
        badge: "ddnet • cheat • crack",
        description: "crack of the cracked version of krx client 1.32 but with non-working cog, archive password: 1",
        image: "https://i.postimg.cc/25c5w7b1/image.png",
        download: "https://drive.google.com/file/d/1DlHPGvhOozqGMM2PliZKBgY6QtD4jjvU/view?usp=sharing",
        arts: [
            "https://i.postimg.cc/kgb7KB0Q/image.png",
            "https://i.postimg.cc/VNFQWMD5/image.png"
        ]
    },
    {
        title: "krx client 1.31 crack",
        type: "ddnet",
        badge: "ddnet • cheat • crack",
        description: "oh a crack 1.31 how original, same logic as the new crack, password: 1",
        image: "https://i.postimg.cc/FKJHr92F/izobrazenie.png",
        download: "https://drive.google.com/file/d/1eTfpQ2yhXJVqJgWP5wokEOalHaJWaTEf/view?usp=sharing",
        arts: [
            "https://i.postimg.cc/kgb7KB0Q/image.png",
            "https://i.postimg.cc/VNFQWMD5/image.png"
        ]
    },
    {
        title: "krx client 1.32 crack NEW",
        type: "ddnet",
        badge: "ddnet • cheat • crack",
        description: "the same crack but a COMPLETELY new version that requires nothing but launching the client, password: 1",
        image: "https://i.postimg.cc/25c5w7b1/image.png",
        download: "https://drive.google.com/file/d/1gZcg93sA82rroRTp8M7NNZRKeeV0hsfF/view?usp=sharing",
        arts: [
            "https://i.postimg.cc/kgb7KB0Q/image.png",
            "https://i.postimg.cc/VNFQWMD5/image.png"
        ]
    },
    {
        title: "krx client 1.30 crack",
        type: "ddnet",
        badge: "ddnet • cheat • crack",
        description: "krx crack 1.30 omg",
        image: "https://i.postimg.cc/Z5NNLzV8/izobrazenie.png",
        download: "https://drive.google.com/file/d/1ZkNg70TlXyHL6iJWhf1pwEQdOMMqDviS/view?usp=sharing",
        arts: [
            "https://i.postimg.cc/kgb7KB0Q/image.png",
            "https://i.postimg.cc/VNFQWMD5/image.png"
        ]
    },
    {
        title: "ae86 client vae6 beta",
        type: "teeworlds cheat",
        badge: "ddnet • cheat",
        description: "new beta version of ae86 client",
        image: "https://i.postimg.cc/TPX4yVND/image.png",
        download: "https://drive.google.com/file/d/1d8EPjCQTdrJj4llGI2QUwnim8d97arUk/view?usp=sharing",
        arts: [
            "https://i.postimg.cc/TYjz6nvn/image.png",
            "https://i.postimg.cc/kMKZQWGt/image.png",
            "https://i.postimg.cc/MTRsY8WL/image.png",
            "https://i.postimg.cc/Qdt0y78g/image.png"
        ]
    },
    {
        title: "dd.cff client",
        type: "ddnet cheat",
        badge: "ddnet • cheat",
        description: "powerful client for ddnet with excellent cheat functionality",
        image: "https://i.postimg.cc/G2v8F0C2/77CC8FC6-1104-4999-8425-9563957F3F83.png",
        download: "https://drive.google.com/file/d/1LpZuH7zDUTwNF1EQowUntNUQDPUwB4CN/view?usp=drive_link",
        arts: ["https://i.postimg.cc/9FGhQvZy/image.png"]
    },
    {
        title: "goreworlds client",
        type: "teeworlds",
        badge: "teeworlds",
        description: "client with 16+ rating as it has blood and other things",
        image: "https://i.postimg.cc/158VnkLQ/Goreworlds-g27du-XIFXy.png",
        download: "https://drive.google.com/file/d/1yF6pZtd9w4x7-uNlRMlN2sDPLAP7aJgc/view?usp=sharing"
    },
    {
        title: "nn client crack",
        type: "ddnet",
        badge: "ddnet • cheat",
        description: "similar to tclientv3 plus but with improved functionality",
        image: "https://i.postimg.cc/B6gS75VW/image.png",
        download: "https://drive.google.com/file/d/1ckCVIP2HAZPDuPsqcsEWJdcTkOnUMuHk/view?usp=sharing"
    },
    {
        title: "sash upgradev32",
        type: "teeworlds cheat",
        badge: "teeworlds • cheat",
        description: "updated version of the popular sash client",
        image: "https://i.postimg.cc/9QGYfLgC/DDNet-f-FKHEV6m-BU.png",
        download: "https://drive.google.com/file/d/1dj57EspAJG3SepJtIx33RY4-R7jiSlhm/view?usp=sharing",
        arts: ["https://i.postimg.cc/nrp1YjSJ/image.png"]
    },
    {
        title: "saiko",
        type: "teeworlds cheat",
        badge: "ddnet • cheat",
        description: "tclient but with avoid freeze functionality support",
        image: "https://i.postimg.cc/CxpZ956N/image.png",
        download: "https://drive.google.com/file/d/1OBtyT__yH9MmuFxgcddySd5B2I3EfTL3/view?usp=sharing"
    },
    {
        title: "MRXClient",
        type: "ddnet cheat",
        badge: "ddnet • cheat",
        description: "client for those who like to stay undetected and play novice maps",
        image: "https://i.postimg.cc/ZRPHGG4q/izobrazenie.png",
        download: "https://drive.google.com/file/d/12gKIkI7XXIhgmpNRsxM9-74HrIx1aT5k/view?usp=sharing"
    },
    {
        title: "Ae86 Client vAe4",
        type: "teeworlds cheat",
        badge: "teeworlds • cheat",
        description: "old version of Ae86 Client",
        image: "https://i.postimg.cc/q7yW7Zpq/izobrazenie.png",
        download: "https://drive.google.com/file/d/1Q-cdqeR3igj8D1Lm40_OLaOuo43a53Ak/view?usp=drive_link",
        arts: [
            "https://i.postimg.cc/TYjz6nvn/image.png",
            "https://i.postimg.cc/kMKZQWGt/image.png",
            "https://i.postimg.cc/MTRsY8WL/image.png",
            "https://i.postimg.cc/Qdt0y78g/image.png"
        ]
    },
    {
        title: "KoshkaClient",
        type: "ddnet",
        badge: "ddnet",
        description: "legit client from the creator of KotClient",
        image: "https://i.postimg.cc/6QxWbjw5/izobrazenie.png",
        download: "https://drive.google.com/file/d/1I7bUk7DFVcEd8MUL6sCXtgvjmx5Fk_3I/view?usp=sharing"
    },
    {
        title: "KotClient",
        type: "ddnet cheat",
        badge: "ddnet • cheat",
        description: "нью клиент, все так же похож на saiko, но функционал гораздо лучше",
        image: "https://i.postimg.cc/0jLGTvM0/izobrazenie.png",
        download: "https://drive.google.com/file/d/10MVoOVDmUfaYvdGdXEmQgr-aBJuoxhvm/view?usp=sharing",
        arts: [
            "https://i.postimg.cc/gkFJqPzF/photo-2025-12-03-12-14-23.jpg",
            "https://i.postimg.cc/6pRk5Gtr/izobrazenie%281%29.jpg",
            "https://i.postimg.cc/DzPR1kWr/izobrazenie%282%29.png"
        ]
    },
    {
        title: "Rclient",
        type: "ddnet",
        badge: "ddnet",
        description: "the BEST client for legits no cap, has literally ALL features",
        image: "https://i.postimg.cc/xTcHF6zq/izobrazenie.png",
        download: "https://drive.google.com/file/d/1WQ6sPMOkWduOunJ5D0iIkOLusapOmBA4/view?usp=sharing"
    },
    {
        title: "E>client",
        type: "ddnet",
        badge: "ddnet",
        description: "legit client suitable for those who don't like something about Rclient",
        image: "https://i.postimg.cc/vB4gSB1R/izobrazenie.png",
        download: "https://drive.google.com/file/d/1WHAjrSdDI3hfBftzrFFzeA0HF6Az2v5C/view?usp=sharing"
    },
    {
        title: "soup",
        type: "teeworlds cheat",
        badge: "ddnet • cheat",
        description: "saiko copycat but with improved avoid, suitable for legits",
        image: "https://i.postimg.cc/fyHYYktn/izobrazenie.png",
        download: "https://drive.google.com/file/d/1m4_s9OnHBNlhoYIaKygvQutLbbKy3ucS/view?usp=sharing",
        discord: "https://discord.gg/ECeDVAEVJn"
    },
    {
        title: "soup beta 1.0.1",
        type: "ddnet cheat",
        badge: "ddnet • cheat",
        description: "new version of soup client, bet better functional",
        image: "https://i.postimg.cc/gk5HGDxY/izobrazenie.png",
        download: "https://drive.google.com/file/d/1ol3-0vZ-iQDfV7n1bGIvmu8MQfMO9mxI/view?usp=sharing",
        discord: "https://discord.gg/ECeDVAEVJn"
    },
    {
        title: "sakura client",
        type: "ddnet",
        badge: "ddnet",
        description: "elegant client with unique design",
        image: "https://i.postimg.cc/YCT1ndNg/DDNet-Nvq-Le-PTl3l.png",
        download: "https://drive.google.com/file/d/1dAN7qLy7EBhL5fpjM2Q3dgUNOO-o7bYl/view?usp=sharing"
    },
    {
        title: "sash by akrd1337",
        type: "teeworlds cheat",
        badge: "teeworlds • cheat",
        description: "modified version of sash client",
        image: "https://i.postimg.cc/RF0yrWQr/Sash-crack-9-Bk-Px-GRpz-A.png",
        download: "https://drive.google.com/file/d/1TZLt4QWUcG5BXxzw4_BLi4f6yJMbs3hQ/view?usp=sharing",
        arts: ["https://i.postimg.cc/nrp1YjSJ/image.png"]
    },
    {
        title: "ChillerBot Client",
        type: "teeworlds",
        badge: "teeworlds",
        description: "idk some random stuff<3",
        image: "https://i.postimg.cc/GtSjQTWk/izobrazenie.png",
        download: "https://drive.google.com/drive/folders/1BEnkumBWMuws3Qy2k6rD27WSynLsFj-6?usp=sharing"
    },
    {
        title: "PPDDNet Client",
        type: "ddnet",
        badge: "ddnet",
        description: "the web creator couldn't launch this client",
        image: "https://i.postimg.cc/NjVjcGcf/izobrazenie.png",
        download: "https://drive.google.com/drive/folders/1Vt951yPEZR83FyrLcGw9HJiZDw76t9ws?usp=sharing"
    },
    {
        title: "jimjam client",
        type: "teeworlds",
        badge: "teeworlds",
        description: "cool client with many different useful features",
        image: "https://i.postimg.cc/HWZ7LYvz/jimjam.png",
        download: "https://drive.google.com/file/d/1_o3R3FQs3Jv3ARDJKz2EslMxJLbZPJZG/view?usp=sharing"
    },
    {
        title: "k-client",
        type: "teeworlds cheat",
        badge: "teeworlds • cheat",
        description: "client similar to krx but for teeworlds",
        image: "https://i.postimg.cc/HxtXzb21/K-Client-ENFC6b2kks.png",
        download: "https://drive.google.com/file/d/1CknKAMSTwWoU3OlPwMacin0mqfAaBiRY/view?usp=sharing"
    },
    {
        title: "mario client",
        type: "teeworlds",
        badge: "teeworlds",
        description: "themed client with one feature that adds visual mario to the server",
        image: "https://i.postimg.cc/qMqych6W/mario.png",
        download: "https://drive.google.com/file/d/1wrDlSev7R_3c33wP87tXaFD2dLireEL-/view?usp=sharing"
    },
    {
        title: "dperx",
        type: "ddnet",
        badge: "ddnet • cheat",
        description: "not exactly a client, injects into ddnet itself and adds cheats through it",
        image: "https://i.postimg.cc/yNZq5Z7K/izobrazenie.png",
        download: "https://github.com/kiocode/DPerX-Reborn/releases/download/1.1.4/dperx-reborn-1.1.4-setup.exe"
    },
    {
        title: "pulse client",
        type: "ddnet",
        badge: "ddnet",
        description: "new client heavily inspired by cactus client",
        image: "https://i.postimg.cc/Pf218zJm/pulse-client.png",
        download: "https://drive.google.com/file/d/100huDXqIS2xmbM1vxAi3YCM_UjxInq8l/view?usp=sharing"
    },
    {
        title: "s-client",
        type: "teeworlds",
        badge: "teeworlds",
        description: "client similar to tclient but for teeworlds",
        image: "https://i.postimg.cc/d3HdPvpW/S-Client-Ys-E8k9f-B1w.png",
        download: "https://drive.google.com/file/d/1bUL49r3GTPZInQUZx-fr_WtNmaEanUU4/view?usp=sharing"
    },
    {
        title: "sqclient",
        type: "ddnet cheat",
        badge: "ddnet • cheat",
        description: "new cheat client, or rather its cracked version, modification of tclient but with cheats",
        image: "https://i.postimg.cc/vZ6njJzz/SQClient.png",
        download: "https://drive.google.com/file/d/1nAvrsid6ZItkiCzBzBcDToCNjskj5pnC/view?usp=sharing"
    },
    {
        title: "sta client",
        type: "teeworlds cheat",
        badge: "teeworlds • cheat",
        description: "stable client with extended functionality created by a ddnet moderator",
        image: "https://i.postimg.cc/W4Gkp0xq/Sta.png",
        download: "https://drive.google.com/file/d/1aL4HRDIPJvvzsQ0IaFM03ymjDmUCvdCJ/view?usp=sharing"
    },
    {
        title: "tclientv3+",
        type: "ddnet cheat",
        badge: "ddnet • cheat",
        description: "old version of the popular tclient but with cheat functionality",
        image: "https://i.postimg.cc/7L8zyKty/Tclient-Plus.png",
        download: "https://drive.google.com/file/d/1Z019ZmXcA936aFyiz3Qv65Mx8lYpm_NP/view?usp=sharing",
        arts: ["https://i.postimg.cc/Z5CxchH8/image.png"]
    },
    {
        title: "vbot client",
        type: "teeworlds cheat",
        badge: "teeworlds • cheat",
        description: "cheat client with a bot",
        image: "https://i.postimg.cc/LXmZJnMC/vbot.png",
        download: "https://drive.google.com/file/d/1wyWOSwKvVmb7XYczlA_s9tcBpzsFHspm/view?usp=sharing"
    },
    {
        title: "zyro client",
        type: "ddnet cheat",
        badge: "ddnet • cheat",
        description: "cheat client created to provide small assistance to developers in creating new clients",
        image: "https://i.postimg.cc/9M1wZCmW/zyro.png",
        download: "https://drive.google.com/file/d/19rqXCnSE3A1t8-qOwJrn-MB7UedwzrdS/view?usp=sharing"
    },
    {
        title: "cactus client",
        type: "ddnet",
        badge: "ddnet",
        description: "almost the same client as tclient but created in Russian",
        image: "https://i.postimg.cc/6pdSr5SJ/DDNet-0-FDBKfkq-Sp.png",
        download: "https://drive.google.com/file/d/1T7T110zIphf9PGiXL-5e0H5TWM6SrP6x/view?usp=sharing",
        arts: ["https://i.postimg.cc/J0rbBwtN/image.png"]
    },
    {
        title: "cactus client private",
        type: "ddnet",
        badge: "ddnet",
        description: "the same cactus client but cracked private version",
        image: "https://i.postimg.cc/W1j9TM9Y/image.png",
        download: "https://drive.google.com/file/d/1SyKu6KNSZIDOl_Psex72ydLy8GrWt4f6/view?usp=sharing",
        arts: ["https://i.postimg.cc/J0rbBwtN/image.png"]
    },
    {
        title: "tater client",
        type: "ddnet",
        badge: "ddnet",
        description: "modification of ddnet client with its own visual functionality",
        image: "https://i.postimg.cc/L53Dqn5N/DDNet-Kkrd-PXJh-TN.png",
        download: "https://drive.google.com/file/d/1Edpb1pXB6_WngDM1XhqiGJL4bDGKJ85T/view?usp=sharing",
        arts: ["https://i.postimg.cc/Z5CxchH8/image.png"]
    }
];

let current_gallery = []
let current_gallery_index = 0
let flip_index = 0
let phrase_index = 0
let char_index = 0
let is_deleting = false
let placeholder_index = 0
let counters_animated = false

function debounce(fn, wait) {
    let t
    return function() {
        clearTimeout(t)
        t = setTimeout(() => fn.apply(this, arguments), wait)
    }
}

function render_clients() {
    const grid = document.getElementById('clientsGrid')
    if (!grid) return
    
    const frag = document.createDocumentFragment()
    
    clientsData.forEach((client, i) => {
        const card = document.createElement('div')
        card.className = 'client-card'
        card.setAttribute('data-type', client.type)
        
        let art_btn = ''
        if (client.arts && client.arts.length > 0) {
            art_btn = `<button class="card-btn art" onclick="open_art_gallery(${i})"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="18" height="18" rx="2"/><circle cx="8.5" cy="8.5" r="1.5"/><polyline points="21 15 16 10 5 21"/></svg>Arts</button>`
        }
        
        let discord_btn = ''
        if (client.discord) {
            discord_btn = `<a href="${client.discord}" class="card-btn outline" target="_blank"><svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M20.317 4.37a19.79 19.79 0 0 0-4.885-1.515.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0 12.64 12.64 0 0 0-.617-1.25.077.077 0 0 0-.079-.037A19.74 19.74 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.08.08 0 0 0 .031.057 19.9 19.9 0 0 0 5.993 3.03.078.078 0 0 0 .084-.028c.462-.63.874-1.295 1.226-1.994a.076.076 0 0 0-.041-.106 13.1 13.1 0 0 1-1.872-.892.077.077 0 0 1-.008-.128c.126-.094.252-.192.372-.292a.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127 12.3 12.3 0 0 1-1.873.892.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028 19.84 19.84 0 0 0 6.002-3.03.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.06.06 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.956-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.955-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.946 2.418-2.157 2.418z"/></svg>Discord</a>`
        }
        
        let telegram_btn = ''
        if (client.telegram) {
            telegram_btn = `<a href="${client.telegram}" class="card-btn outline" target="_blank"><svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor"><path d="M11.944 0A12 12 0 0 0 0 12a12 12 0 0 0 12 12 12 12 0 0 0 12-12A12 12 0 0 0 12 0a12 12 0 0 0-.056 0zm4.962 7.224c.1-.002.321.023.465.14a.506.506 0 0 1 .171.325c.016.093.036.306.02.472-.18 1.898-.962 6.502-1.36 8.627-.168.9-.499 1.201-.82 1.23-.696.065-1.225-.46-1.9-.902-1.056-.693-1.653-1.124-2.678-1.8-1.185-.78-.417-1.21.258-1.91.177-.184 3.247-2.977 3.307-3.23.007-.032.014-.15-.056-.212s-.174-.041-.249-.024c-.106.024-1.793 1.14-5.061 3.345-.48.33-.913.49-1.302.48-.428-.008-1.252-.241-1.865-.44-.752-.245-1.349-.374-1.297-.789.027-.216.325-.437.893-.663 3.498-1.524 5.83-2.529 6.998-3.014 3.332-1.386 4.025-1.627 4.476-1.635z"/></svg>Telegram</a>`
        }
        
        let download_btn = ''
        if (client.download) {
            download_btn = `<a href="${client.download}" class="card-btn" target="_blank"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>Download</a>`
        } else if (client.buy) {
            download_btn = `<a href="${client.buy}" class="card-btn" target="_blank"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="9" cy="21" r="1"/><circle cx="20" cy="21" r="1"/><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"/></svg>Buy</a>`
        }
        
        card.innerHTML = `
            <div class="card-img">
                <img src="${client.image}" alt="${client.title}" loading="lazy">
                <span class="card-badge">${client.badge}</span>
            </div>
            <div class="card-body">
                <h3 class="card-title">${client.title}</h3>
                <p class="card-desc">${client.description}</p>
                <div class="card-buttons">
                    <button class="card-btn outline" onclick="open_image_modal('${client.image}')">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/>
                            <circle cx="12" cy="12" r="3"/>
                        </svg>Preview
                    </button>
                    ${art_btn}
                    ${discord_btn}
                    ${telegram_btn}
                    ${download_btn}
                </div>
            </div>
        `
        frag.appendChild(card)
    })
    
    grid.innerHTML = ''
    grid.appendChild(frag)
}

function init_globe() {
    const canvas = document.getElementById('globeCanvas')
    if (!canvas || typeof THREE === 'undefined') return
    
    const container = document.getElementById('globeContainer')
    const width = container.offsetWidth
    const height = container.offsetHeight
    
    const scene = new THREE.Scene()
    
    const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000)
    camera.position.z = 300
    
    const renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true,
        alpha: true
    })
    renderer.setSize(width, height)
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
    
    const ambientLight = new THREE.AmbientLight(0x404040, 0.5)
    scene.add(ambientLight)
    
    const pointLight = new THREE.PointLight(0xdc2626, 1, 500)
    pointLight.position.set(100, 100, 150)
    scene.add(pointLight)
    
    const pointLight2 = new THREE.PointLight(0x3b82f6, 0.5, 500)
    pointLight2.position.set(-100, -100, 150)
    scene.add(pointLight2)
    
    const globeGeometry = new THREE.SphereGeometry(100, 64, 64)
    const globeMaterial = new THREE.MeshPhongMaterial({
        color: 0x1a1a2e,
        emissive: 0x0a0a15,
        emissiveIntensity: 0.2,
        shininess: 10,
        transparent: true,
        opacity: 0.95
    })
    const globe = new THREE.Mesh(globeGeometry, globeMaterial)
    scene.add(globe)
    
    const atmosphereGeometry = new THREE.SphereGeometry(102, 64, 64)
    const atmosphereMaterial = new THREE.ShaderMaterial({
        vertexShader: `
            varying vec3 vNormal;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            varying vec3 vNormal;
            void main() {
                float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                gl_FragColor = vec4(0.86, 0.15, 0.15, 1.0) * intensity;
            }
        `,
        blending: THREE.AdditiveBlending,
        side: THREE.BackSide,
        transparent: true
    })
    const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial)
    scene.add(atmosphere)
    
    const gridMaterial = new THREE.LineBasicMaterial({ 
        color: 0x7f1d1d, 
        transparent: true, 
        opacity: 0.3 
    })
    
    for (let i = 0; i < 12; i++) {
        const curve = new THREE.EllipseCurve(0, 0, 100, 100, 0, 2 * Math.PI, false, 0)
        const points = curve.getPoints(64)
        const geometry = new THREE.BufferGeometry().setFromPoints(points)
        const meridian = new THREE.Line(geometry, gridMaterial)
        meridian.rotation.y = (i / 12) * Math.PI
        globe.add(meridian)
    }
    
    for (let i = 1; i < 6; i++) {
        const radius = 100 * Math.cos((i / 6) * Math.PI / 2)
        const y = 100 * Math.sin((i / 6) * Math.PI / 2)
        const curve = new THREE.EllipseCurve(0, 0, radius, radius, 0, 2 * Math.PI, false, 0)
        const points = curve.getPoints(64)
        const geometry = new THREE.BufferGeometry().setFromPoints(points)
        
        const parallel1 = new THREE.Line(geometry, gridMaterial)
        parallel1.position.y = y
        parallel1.rotation.x = Math.PI / 2
        globe.add(parallel1)
        
        const parallel2 = new THREE.Line(geometry, gridMaterial)
        parallel2.position.y = -y
        parallel2.rotation.x = Math.PI / 2
        globe.add(parallel2)
    }
    
    function latLngToVector3(lat, lng, radius) {
        const phi = (90 - lat) * (Math.PI / 180)
        const theta = (lng + 180) * (Math.PI / 180)
        return new THREE.Vector3(
            -radius * Math.sin(phi) * Math.cos(theta),
            radius * Math.cos(phi),
            radius * Math.sin(phi) * Math.sin(theta)
        )
    }
    
    const cities = [
        { lat: 40.7128, lng: -74.006, name: 'New York' },
        { lat: 51.5074, lng: -0.1278, name: 'London' },
        { lat: 35.6762, lng: 139.6503, name: 'Tokyo' },
        { lat: 22.3193, lng: 114.1694, name: 'Hong Kong' },
        { lat: -33.8688, lng: 151.2093, name: 'Sydney' },
        { lat: 55.7558, lng: 37.6173, name: 'Moscow' },
        { lat: 25.2048, lng: 55.2708, name: 'Dubai' },
        { lat: -23.5505, lng: -46.6333, name: 'Sao Paulo' },
        { lat: 1.3521, lng: 103.8198, name: 'Singapore' },
        { lat: 48.8566, lng: 2.3522, name: 'Paris' }
    ]
    
    const pointsGroup = new THREE.Group()
    const pointGeometry = new THREE.SphereGeometry(2, 16, 16)
    const pointMaterial = new THREE.MeshBasicMaterial({ color: 0xef4444 })
    
    cities.forEach(function(city) {
        const pos = latLngToVector3(city.lat, city.lng, 101)
        const point = new THREE.Mesh(pointGeometry, pointMaterial)
        point.position.copy(pos)
        pointsGroup.add(point)
        
        const ringGeometry = new THREE.RingGeometry(3, 4, 32)
        const ringMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xef4444, 
            transparent: true, 
            opacity: 0.5,
            side: THREE.DoubleSide
        })
        const ring = new THREE.Mesh(ringGeometry, ringMaterial)
        ring.position.copy(pos)
        ring.lookAt(0, 0, 0)
        pointsGroup.add(ring)
    })
    globe.add(pointsGroup)
    
    const arcConnections = [
        [0, 1], [1, 9], [9, 5], [5, 6], [6, 8], [8, 3], [3, 2], [2, 4],
        [0, 7], [1, 6], [2, 8], [4, 8], [5, 3]
    ]
    
    const colors = [0xdc2626, 0xef4444, 0xf87171, 0x3b82f6, 0x06b6d4]
    const arcsGroup = new THREE.Group()
    
    arcConnections.forEach(function(conn, index) {
        const start = latLngToVector3(cities[conn[0]].lat, cities[conn[0]].lng, 100)
        const end = latLngToVector3(cities[conn[1]].lat, cities[conn[1]].lng, 100)
        
        const mid = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5)
        const distance = start.distanceTo(end)
        mid.normalize().multiplyScalar(100 + distance * 0.4)
        
        const curve = new THREE.QuadraticBezierCurve3(start, mid, end)
        const points = curve.getPoints(50)
        const geometry = new THREE.BufferGeometry().setFromPoints(points)
        
        const color = colors[index % colors.length]
        const material = new THREE.LineBasicMaterial({ 
            color: color,
            transparent: true,
            opacity: 0.6
        })
        
        const arc = new THREE.Line(geometry, material)
        arc.userData = { 
            progress: Math.random(),
            speed: 0.002 + Math.random() * 0.003,
            points: points,
            color: color
        }
        arcsGroup.add(arc)
    })
    globe.add(arcsGroup)
    
    const particlesGroup = new THREE.Group()
    const particleGeometry = new THREE.SphereGeometry(1.5, 8, 8)
    
    arcsGroup.children.forEach(function(arc) {
        const particleMaterial = new THREE.MeshBasicMaterial({ 
            color: arc.userData.color,
            transparent: true
        })
        const particle = new THREE.Mesh(particleGeometry, particleMaterial)
        particle.userData = arc.userData
        particlesGroup.add(particle)
    })
    globe.add(particlesGroup)
    
    function animate() {
        requestAnimationFrame(animate)
        
        globe.rotation.y += 0.002
        
        particlesGroup.children.forEach(function(particle) {
            particle.userData.progress += particle.userData.speed
            if (particle.userData.progress > 1) particle.userData.progress = 0
            
            const points = particle.userData.points
            const index = Math.floor(particle.userData.progress * (points.length - 1))
            if (points[index]) {
                particle.position.copy(points[index])
            }
            
            const fade = Math.sin(particle.userData.progress * Math.PI)
            particle.material.opacity = fade
        })
        
        renderer.render(scene, camera)
    }
    
    animate()
    
    function onResize() {
        const w = container.offsetWidth
        const h = container.offsetHeight
        camera.aspect = w / h
        camera.updateProjectionMatrix()
        renderer.setSize(w, h)
    }
    
    window.addEventListener('resize', onResize)
}

function create_encrypted_text(element, options) {
    if (!element) return
    
    const text = element.textContent
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*'
    const reveal_delay = options && options.delay ? options.delay : 50
    
    element.innerHTML = ''
    element.classList.add('encrypted-text')
    
    const spans = []
    for (let i = 0; i < text.length; i++) {
        const span = document.createElement('span')
        span.className = 'encrypted-char encrypted'
        span.textContent = text[i] === ' ' ? ' ' : chars[Math.floor(Math.random() * chars.length)]
        span.dataset.original = text[i]
        element.appendChild(span)
        spans.push(span)
    }
    
    let revealed = false
    
    function reveal() {
        if (revealed) return
        revealed = true
        
        spans.forEach(function(span, i) {
            let iterations = 0
            const max_iterations = 3 + Math.floor(Math.random() * 5)
            
            const interval = setInterval(function() {
                if (span.dataset.original === ' ') {
                    span.textContent = ' '
                    clearInterval(interval)
                    return
                }
                
                if (iterations >= max_iterations) {
                    span.textContent = span.dataset.original
                    span.classList.remove('encrypted')
                    span.classList.add('revealed')
                    clearInterval(interval)
                } else {
                    span.textContent = chars[Math.floor(Math.random() * chars.length)]
                    iterations++
                }
            }, reveal_delay)
        })
    }
    
    return { reveal: reveal }
}

function create_sparkles_text(element) {
    if (!element) return
    
    element.classList.add('sparkles-text')
    
    const container = document.createElement('div')
    container.className = 'sparkles-container'
    element.appendChild(container)
    
    let active = false
    let interval_id = null
    
    function create_sparkle() {
        const sparkle = document.createElement('div')
        sparkle.className = 'sparkle'
        sparkle.style.left = Math.random() * 100 + '%'
        sparkle.style.top = Math.random() * 100 + '%'
        sparkle.style.animationDuration = (1 + Math.random() * 0.5) + 's'
        
        const size = 8 + Math.random() * 8
        sparkle.style.width = size + 'px'
        sparkle.style.height = size + 'px'
        
        sparkle.innerHTML = '<svg viewBox="0 0 24 24"><path d="M12 0L14.59 9.41L24 12L14.59 14.59L12 24L9.41 14.59L0 12L9.41 9.41L12 0Z"/></svg>'
        
        container.appendChild(sparkle)
        
        setTimeout(function() {
            sparkle.remove()
        }, 1500)
    }
    
    function start() {
        if (active) return
        active = true
        
        for (let i = 0; i < 3; i++) {
            setTimeout(create_sparkle, i * 200)
        }
        
        interval_id = setInterval(create_sparkle, 300)
    }
    
    function stop() {
        active = false
        if (interval_id) {
            clearInterval(interval_id)
            interval_id = null
        }
    }
    
    return { start: start, stop: stop }
}

function create_word_reveal(element) {
    if (!element) return
    
    const text = element.textContent
    const words = text.split(' ')
    
    element.innerHTML = ''
    element.classList.add('word-reveal')
    
    words.forEach(function(word, i) {
        const span = document.createElement('span')
        span.className = 'word'
        span.textContent = word
        span.style.transitionDelay = (i * 0.1) + 's'
        element.appendChild(span)
    })
}

function create_char_reveal(element) {
    if (!element) return
    
    const text = element.textContent
    
    element.innerHTML = ''
    element.classList.add('char-reveal')
    
    for (let i = 0; i < text.length; i++) {
        const span = document.createElement('span')
        span.className = 'char'
        span.textContent = text[i] === ' ' ? '\u00A0' : text[i]
        span.style.transitionDelay = (i * 0.03) + 's'
        element.appendChild(span)
    }
}

function init_text_effects() {
    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*<>[]{}|;:,.?/~`'
    var effects_data = []
    
    document.querySelectorAll('[data-encrypted]').forEach(function(el) {
        var original_text = el.textContent
        el.innerHTML = ''
        el.classList.add('encrypted-text')
        
        var char_elements = []
        for (var i = 0; i < original_text.length; i++) {
            var span = document.createElement('span')
            span.className = 'encrypted-char' + (original_text[i] === ' ' ? ' space' : '')
            span.dataset.char = original_text[i]
            
            if (original_text[i] === ' ') {
                span.innerHTML = '&nbsp;'
            } else {
                span.textContent = chars[Math.floor(Math.random() * chars.length)]
                span.classList.add('encrypted')
            }
            
            el.appendChild(span)
            char_elements.push(span)
        }
        
        effects_data.push({
            type: 'encrypted',
            el: el,
            chars: char_elements,
            original: original_text,
            revealed: false
        })
    })
    
    document.querySelectorAll('[data-sparkles]').forEach(function(el) {
        el.classList.add('sparkles-text')
        
        var container = document.createElement('div')
        container.className = 'sparkles-container'
        el.appendChild(container)
        
        effects_data.push({
            type: 'sparkles',
            el: el,
            container: container,
            active: false,
            interval: null
        })
    })
    
    document.querySelectorAll('[data-word-reveal]').forEach(function(el) {
        var text = el.textContent
        var words = text.split(/\s+/)
        
        el.innerHTML = ''
        
        var wrapper = document.createElement('span')
        wrapper.className = 'word-reveal-wrapper'
        
        words.forEach(function(word, i) {
            if (word.trim() === '') return
            
            var span = document.createElement('span')
            span.className = 'word-reveal-word'
            span.textContent = word
            span.style.transitionDelay = (i * 0.08) + 's'
            wrapper.appendChild(span)
        })
        
        el.appendChild(wrapper)
        
        effects_data.push({
            type: 'word-reveal',
            el: el,
            wrapper: wrapper,
            revealed: false
        })
    })
    
    document.querySelectorAll('[data-char-reveal]').forEach(function(el) {
        var text = el.textContent
        
        el.innerHTML = ''
        
        var wrapper = document.createElement('span')
        wrapper.className = 'char-reveal-wrapper'
        
        for (var i = 0; i < text.length; i++) {
            var span = document.createElement('span')
            span.className = 'char-reveal-char'
            span.textContent = text[i] === ' ' ? '\u00A0' : text[i]
            span.style.transitionDelay = (i * 0.04) + 's'
            wrapper.appendChild(span)
        }
        
        el.appendChild(wrapper)
        
        effects_data.push({
            type: 'char-reveal',
            el: el,
            wrapper: wrapper,
            revealed: false
        })
    })
    
    document.querySelectorAll('[data-glitch]').forEach(function(el) {
        var text = el.textContent
        
        el.innerHTML = ''
        
        var wrapper = document.createElement('span')
        wrapper.className = 'glitch-wrapper'
        wrapper.textContent = text
        wrapper.dataset.text = text
        
        el.appendChild(wrapper)
        
        effects_data.push({
            type: 'glitch',
            el: el,
            wrapper: wrapper,
            revealed: false
        })
    })
    
    document.querySelectorAll('[data-highlight]').forEach(function(el) {
        var type = el.dataset.highlight || 'box'
        var text = el.textContent
        
        el.innerHTML = ''
        el.classList.add('highlight-' + type)
        
        if (type === 'reveal') {
            el.classList.remove('highlight-reveal')
            el.classList.add('text-reveal-highlight')
            
            var bg = document.createElement('span')
            bg.className = 'text-bg'
            
            var content = document.createElement('span')
            content.className = 'text-content'
            content.textContent = text
            
            el.appendChild(bg)
            el.appendChild(content)
        } else if (type === 'wrapper') {
            var bg = document.createElement('span')
            bg.className = 'highlight-bg'
            el.appendChild(bg)
            
            var textSpan = document.createElement('span')
            textSpan.textContent = text
            el.insertBefore(textSpan, bg)
        } else {
            el.textContent = text
        }
        
        effects_data.push({
            type: 'highlight',
            el: el,
            highlight_type: type,
            activated: false
        })
    })
    
    function reveal_encrypted(data) {
        if (data.revealed) return
        data.revealed = true
        
        data.chars.forEach(function(span, index) {
            if (span.dataset.char === ' ') return
            
            var iterations = 0
            var max_iterations = 5 + Math.floor(Math.random() * 8)
            var delay = index * 30
            
            setTimeout(function() {
                var interval = setInterval(function() {
                    if (iterations >= max_iterations) {
                        span.textContent = span.dataset.char
                        span.classList.remove('encrypted')
                        span.classList.add('revealed')
                        clearInterval(interval)
                    } else {
                        span.textContent = chars[Math.floor(Math.random() * chars.length)]
                        iterations++
                    }
                }, 50)
            }, delay)
        })
    }
    
    function start_sparkles(data) {
        if (data.active) return
        data.active = true
        
        function create_sparkle() {
            var sparkle = document.createElement('div')
            sparkle.className = 'sparkle'
            
            var size = 8 + Math.random() * 12
            sparkle.style.width = size + 'px'
            sparkle.style.height = size + 'px'
            sparkle.style.left = (Math.random() * 100) + '%'
            sparkle.style.top = (Math.random() * 100) + '%'
            sparkle.style.animation = 'sparkle-pop ' + (1 + Math.random() * 0.5) + 's ease-in-out forwards'
            
            sparkle.innerHTML = '<svg viewBox="0 0 24 24"><path d="M12 0L14.59 9.41L24 12L14.59 14.59L12 24L9.41 14.59L0 12L9.41 9.41L12 0Z"/></svg>'
            
            data.container.appendChild(sparkle)
            
            setTimeout(function() {
                if (sparkle.parentNode) {
                    sparkle.remove()
                }
            }, 1500)
        }
        
        create_sparkle()
        create_sparkle()
        create_sparkle()
        
        data.interval = setInterval(function() {
            create_sparkle()
        }, 400)
    }
    
    function reveal_words(data) {
        if (data.revealed) return
        data.revealed = true
        data.wrapper.classList.add('visible')
    }
    
    function reveal_chars(data) {
        if (data.revealed) return
        data.revealed = true
        data.wrapper.classList.add('visible')
    }
    
    function trigger_glitch(data) {
        if (data.revealed) return
        data.revealed = true
        data.wrapper.classList.add('active')
        
        setTimeout(function() {
            data.wrapper.classList.remove('active')
        }, 500)
    }
    
    function activate_highlight(data) {
        if (data.activated) return
        data.activated = true
        data.el.classList.add('active')
    }
    
    var observer = new IntersectionObserver(function(entries) {
        entries.forEach(function(entry) {
            if (!entry.isIntersecting) return
            
            var target = entry.target
            
            if (target.classList.contains('reveal-text')) {
                target.classList.add('visible')
            }
            
            if (target.classList.contains('hero-highlight-title')) {
                target.classList.add('animate')
            }
            
            effects_data.forEach(function(data) {
                if (data.el === target || data.el.contains(target) || target.contains(data.el)) {
                    switch (data.type) {
                        case 'encrypted':
                            reveal_encrypted(data)
                            break
                        case 'sparkles':
                            start_sparkles(data)
                            break
                        case 'word-reveal':
                            reveal_words(data)
                            break
                        case 'char-reveal':
                            reveal_chars(data)
                            break
                        case 'glitch':
                            trigger_glitch(data)
                            break
                        case 'highlight':
                            activate_highlight(data)
                            break
                    }
                }
            })
            
            observer.unobserve(target)
        })
    }, { threshold: 0.3, rootMargin: '0px 0px -50px 0px' })
    
    document.querySelectorAll('.reveal-text, .hero-highlight-title').forEach(function(el) {
        observer.observe(el)
    })
    
    effects_data.forEach(function(data) {
        observer.observe(data.el)
    })
    
    document.querySelectorAll('.hero-content .reveal-text, .hero-content [data-sparkles]').forEach(function(el) {
        el.classList.add('visible')
        
        effects_data.forEach(function(data) {
            if (data.el === el) {
                if (data.type === 'sparkles') {
                    setTimeout(function() { start_sparkles(data) }, 500)
                }
            }
        })
    })
}

function init_lamp() {
    const container = document.getElementById('lampContainer')
    if (!container) return
    
    const observer = new IntersectionObserver(function(entries) {
        entries.forEach(function(entry) {
            if (entry.isIntersecting) {
                const elements = container.querySelectorAll('.lamp-cone, .lamp-cone-inner, .lamp-glow-spot, .lamp-horizon, .lamp-glow-floor, .lamp-content')
                elements.forEach(function(el, i) {
                    setTimeout(function() {
                        el.classList.add('animate')
                    }, i * 100)
                })
                observer.unobserve(entry.target)
            }
        })
    }, { threshold: 0.2 })
    
    observer.observe(container)
}

function init_hero_highlight() {
    var section = document.querySelector('.hero-highlight-section')
    if (!section) return
    
    var title = section.querySelector('.hero-highlight-title')
    if (!title) return
    
    var observer = new IntersectionObserver(function(entries) {
        entries.forEach(function(entry) {
            if (entry.isIntersecting) {
                setTimeout(function() {
                    title.classList.add('animate')
                    
                    var highlights = title.querySelectorAll('[data-highlight]')
                    highlights.forEach(function(el, i) {
                        setTimeout(function() {
                            el.classList.add('active')
                        }, 300 + i * 200)
                    })
                }, 200)
                observer.unobserve(entry.target)
            }
        })
    }, { threshold: 0.3 })
    
    observer.observe(section)
}

function init_sidebar() {
    const sidebar = document.getElementById('sidebar')
    if (!sidebar) return
    
    document.body.classList.add('has-sidebar')
    
    const links = document.querySelectorAll('.sidebar-link')
    const sections = document.querySelectorAll('section[id], .lamp-container')
    
    function update_active_link() {
        let current = 'home'
        const scroll_pos = window.scrollY + 150
        
        sections.forEach(function(section) {
            const top = section.offsetTop
            const height = section.offsetHeight
            const id = section.getAttribute('id')
            
            if (id && scroll_pos >= top && scroll_pos < top + height) {
                current = id
            }
        })
        
        links.forEach(function(link) {
            link.classList.remove('active')
            const section = link.getAttribute('data-section')
            if (section === current) {
                link.classList.add('active')
            }
        })
    }
    
    window.addEventListener('scroll', update_active_link, { passive: true })
    update_active_link()
    
    links.forEach(function(link) {
        link.addEventListener('click', function(e) {
            e.preventDefault()
            const href = this.getAttribute('href')
            const target = document.querySelector(href)
            
            if (target) {
                const offset = 100
                window.scrollTo({
                    top: target.offsetTop - offset,
                    behavior: 'smooth'
                })
            }
        })
    })
}

function flip_word() {
    const words = document.querySelectorAll('.flip-word')
    if (words.length === 0) return
    
    const current = words[flip_index]
    current.classList.remove('active')
    current.style.opacity = '0'
    current.style.transform = 'translateY(-20px)'
    current.style.filter = 'blur(4px)'
    
    flip_index = (flip_index + 1) % words.length
    
    const next = words[flip_index]
    next.style.transform = 'translateY(20px)'
    
    setTimeout(function() {
        next.classList.add('active')
        next.style.opacity = '1'
        next.style.transform = 'translateY(0)'
        next.style.filter = 'blur(0)'
    }, 200)
}

function init_flip_words() {
    const words = document.querySelectorAll('.flip-word')
    words.forEach(function(word, i) {
        word.style.transition = 'all 0.4s ease'
        if (i === 0) {
            word.classList.add('active')
            word.style.opacity = '1'
            word.style.transform = 'translateY(0)'
            word.style.filter = 'blur(0)'
        } else {
            word.style.opacity = '0'
            word.style.transform = 'translateY(20px)'
            word.style.filter = 'blur(4px)'
        }
    })
    setInterval(flip_word, 2500)
}

const typing_phrases = [
    'carefully collected and verified',
    'tested on real machines',
    'updated with new releases',
    'completely free to use',
    'built for the community'
]

function type_text() {
    const element = document.getElementById('typingText')
    if (!element) return
    
    const current_phrase = typing_phrases[phrase_index]
    
    if (is_deleting) {
        char_index--
        element.textContent = current_phrase.substring(0, char_index)
    } else {
        char_index++
        element.textContent = current_phrase.substring(0, char_index)
    }
    
    let speed = is_deleting ? 30 : 70
    
    if (!is_deleting && char_index === current_phrase.length) {
        speed = 2000
        is_deleting = true
    } else if (is_deleting && char_index === 0) {
        is_deleting = false
        phrase_index = (phrase_index + 1) % typing_phrases.length
        speed = 500
    }
    
    setTimeout(type_text, speed)
}

const search_placeholders = [
    'Search for DDNet clients...',
    'Find Teeworlds mods...',
    'Looking for something?',
    'Type client name...',
    'Discover new clients...'
]

function change_placeholder() {
    const input = document.getElementById('searchInput')
    if (!input) return
    if (document.activeElement === input) return
    
    placeholder_index = (placeholder_index + 1) % search_placeholders.length
    input.placeholder = search_placeholders[placeholder_index]
}

function init_placeholder() {
    const input = document.getElementById('searchInput')
    if (input) {
        input.placeholder = search_placeholders[0]
        setInterval(change_placeholder, 3500)
    }
}

function init_terminal() {
    const terminal = document.querySelector('.about-block.terminal')
    if (!terminal) return
    
    const lines = terminal.querySelectorAll('.terminal-line')
    let animated = false
    
    const observer = new IntersectionObserver(function(entries) {
        entries.forEach(function(entry) {
            if (entry.isIntersecting && !animated) {
                animated = true
                lines.forEach(function(line, i) {
                    line.style.opacity = '0'
                    line.style.transform = 'translateX(-10px)'
                    line.style.transition = 'all 0.4s ease'
                    
                    setTimeout(function() {
                        line.style.opacity = '1'
                        line.style.transform = 'translateX(0)'
                    }, 300 + i * 250)
                })
                observer.unobserve(entry.target)
            }
        })
    }, { threshold: 0.5 })
    
    observer.observe(terminal)
}

function animate_counter(element, target) {
    let current = 0
    const duration = 2000
    const start_time = performance.now()
    
    function update(current_time) {
        const elapsed = current_time - start_time
        const progress = Math.min(elapsed / duration, 1)
        const ease = 1 - Math.pow(1 - progress, 3)
        
        current = Math.floor(ease * target)
        element.textContent = current
        
        if (progress < 1) {
            requestAnimationFrame(update)
        } else {
            element.textContent = target
        }
    }
    
    requestAnimationFrame(update)
}

function init_counters() {
    const section = document.getElementById('stats')
    if (!section) return
    
    const observer = new IntersectionObserver(function(entries) {
        entries.forEach(function(entry) {
            if (entry.isIntersecting && !counters_animated) {
                counters_animated = true
                
                document.querySelectorAll('.stat-value').forEach(function(el) {
                    const target = parseInt(el.getAttribute('data-count'))
                    animate_counter(el, target)
                })
                
                observer.unobserve(entry.target)
            }
        })
    }, { threshold: 0.3 })
    
    observer.observe(section)
}

function init_scroll() {
    const header = document.getElementById('header')
    const scroll_btn = document.getElementById('scrollTop')
    
    window.addEventListener('scroll', function() {
        const y = window.scrollY
        
        if (y > 50) {
            header.classList.add('scrolled')
        } else {
            header.classList.remove('scrolled')
        }
        
        if (y > 500) {
            scroll_btn.classList.add('visible')
        } else {
            scroll_btn.classList.remove('visible')
        }
    }, { passive: true })
    
    scroll_btn.addEventListener('click', function() {
        window.scrollTo({ top: 0, behavior: 'smooth' })
    })
}

function init_navigation() {
    const toggle = document.getElementById('menuToggle')
    const menu = document.getElementById('navMenu')
    
    if (toggle && menu) {
        toggle.addEventListener('click', function() {
            toggle.classList.toggle('active')
            menu.classList.toggle('active')
        })
    }
    
    document.querySelectorAll('a[href^="#"]').forEach(function(link) {
        link.addEventListener('click', function(e) {
            e.preventDefault()
            const target_id = this.getAttribute('href')
            const target = document.querySelector(target_id)
            
            if (target) {
                const offset = 80
                window.scrollTo({
                    top: target.offsetTop - offset,
                    behavior: 'smooth'
                })
                if (menu) menu.classList.remove('active')
                if (toggle) toggle.classList.remove('active')
            }
        })
    })
}

function init_search() {
    const input = document.getElementById('searchInput')
    if (!input) return
    
    input.addEventListener('input', debounce(function(e) {
        const term = e.target.value.toLowerCase()
        
        document.querySelectorAll('.client-card').forEach(function(card) {
            const title = card.querySelector('.card-title').textContent.toLowerCase()
            const desc = card.querySelector('.card-desc').textContent.toLowerCase()
            
            if (title.includes(term) || desc.includes(term)) {
                card.classList.remove('hidden')
            } else {
                card.classList.add('hidden')
            }
        })
    }, 200))
}

function init_filters() {
    document.querySelectorAll('.filter-btn').forEach(function(btn) {
        btn.addEventListener('click', function() {
            document.querySelectorAll('.filter-btn').forEach(function(b) {
                b.classList.remove('active')
            })
            this.classList.add('active')
            
            const filter = this.getAttribute('data-filter')
            
            document.querySelectorAll('.client-card').forEach(function(card) {
                const types = card.getAttribute('data-type') || ''
                
                if (filter === 'all' || types.includes(filter)) {
                    card.classList.remove('hidden')
                } else {
                    card.classList.add('hidden')
                }
            })
        })
    })
}

function open_image_modal(src) {
    const modal = document.getElementById('imageModal')
    const img = document.getElementById('modalImage')
    
    img.src = src
    modal.classList.add('active')
    document.body.style.overflow = 'hidden'
}

function close_image_modal() {
    const modal = document.getElementById('imageModal')
    modal.classList.remove('active')
    document.body.style.overflow = ''
}

window.open_image_modal = open_image_modal

function open_art_gallery(index) {
    const client = clientsData[index]
    if (!client.arts || client.arts.length === 0) return
    
    current_gallery = client.arts
    current_gallery_index = 0
    
    const gallery = document.getElementById('artGallery')
    const img = document.getElementById('galleryImage')
    const dots = document.getElementById('galleryDots')
    
    img.src = current_gallery[0]
    
    dots.innerHTML = ''
    current_gallery.forEach(function(_, i) {
        const dot = document.createElement('div')
        dot.className = 'gallery-dot'
        if (i === 0) dot.classList.add('active')
        dot.addEventListener('click', function() {
            go_to_image(i)
        })
        dots.appendChild(dot)
    })
    
    update_gallery_counter()
    gallery.classList.add('active')
    document.body.style.overflow = 'hidden'
}

function go_to_image(i) {
    current_gallery_index = i
    
    const img = document.getElementById('galleryImage')
    img.src = current_gallery[i]
    
    document.querySelectorAll('.gallery-dot').forEach(function(dot, index) {
        if (index === i) {
            dot.classList.add('active')
        } else {
            dot.classList.remove('active')
        }
    })
    
    update_gallery_counter()
}

function update_gallery_counter() {
    const counter = document.getElementById('galleryCount')
    if (counter) {
        counter.textContent = (current_gallery_index + 1) + ' / ' + current_gallery.length
    }
}

function close_gallery() {
    const gallery = document.getElementById('artGallery')
    gallery.classList.remove('active')
    document.body.style.overflow = ''
}

window.open_art_gallery = open_art_gallery

function init_modals() {
    const modal_close = document.getElementById('modalClose')
    const image_modal = document.getElementById('imageModal')
    const gallery_close = document.getElementById('galleryClose')
    const gallery_prev = document.getElementById('galleryPrev')
    const gallery_next = document.getElementById('galleryNext')
    const art_gallery = document.getElementById('artGallery')
    
    if (modal_close) {
        modal_close.addEventListener('click', close_image_modal)
    }
    
    if (image_modal) {
        image_modal.addEventListener('click', function(e) {
            if (e.target === image_modal) {
                close_image_modal()
            }
        })
    }
    
    if (gallery_close) {
        gallery_close.addEventListener('click', close_gallery)
    }
    
    if (gallery_prev) {
        gallery_prev.addEventListener('click', function() {
            const new_index = (current_gallery_index - 1 + current_gallery.length) % current_gallery.length
            go_to_image(new_index)
        })
    }
    
    if (gallery_next) {
        gallery_next.addEventListener('click', function() {
            const new_index = (current_gallery_index + 1) % current_gallery.length
            go_to_image(new_index)
        })
    }
    
    if (art_gallery) {
        art_gallery.addEventListener('click', function(e) {
            if (e.target === art_gallery) {
                close_gallery()
            }
        })
    }
    
    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
            close_image_modal()
            close_gallery()
        }
        
        const gallery = document.getElementById('artGallery')
        if (gallery && gallery.classList.contains('active')) {
            if (e.key === 'ArrowRight') {
                const new_index = (current_gallery_index + 1) % current_gallery.length
                go_to_image(new_index)
            }
            if (e.key === 'ArrowLeft') {
                const new_index = (current_gallery_index - 1 + current_gallery.length) % current_gallery.length
                go_to_image(new_index)
            }
        }
    })
}

function init_card_hover() {
    if (window.innerWidth < 768) return
    
    document.querySelectorAll('.feature-card, .client-card').forEach(function(card) {
        card.addEventListener('mouseenter', function() {
            this.style.transform = 'translateY(-8px)'
        })
        
        card.addEventListener('mouseleave', function() {
            this.style.transform = 'translateY(0)'
        })
    })
}

function init() {
    render_clients()
    init_flip_words()
    init_placeholder()
    init_terminal()
    init_counters()
    init_scroll()
    init_navigation()
    init_search()
    init_filters()
    init_modals()
    init_card_hover()
    init_globe()
    init_lamp()
    init_hero_highlight()
    init_sidebar()
    init_text_effects()
    
    setTimeout(type_text, 1000)
}

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init)
} else {
    init()
}
